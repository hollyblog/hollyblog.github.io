
[{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/categories/resume/","section":"Categories","summary":"","title":"Resume","type":"categories"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/resume/","section":"Tags","summary":"","title":"Resume","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 👧Holly 求职意向：后端开发工程师 工作经验：三年（含个人项目实战） 电话：131****6107 出生年月：1996年08月 邮箱：2285549633@qq.com 🚀教育及工作经历 # 2015.09 - 2019.07 山东建筑大学 软件工程 本科 2019.09 - 2022.07 大连理工大学 软件工程 硕士 2022.07 - 2023.04 北京金山云 公有云 后端工程师 2023.05 - 2025.11 个人创业项目 餐饮业务 全栈工程师 🔨专业技能 # 大模型应用开发：掌握LangChain4J框架，具备构建RAG系统、Agents的实战经验；熟悉提示工程原则，了解大模型微调方法；具备本地部署开源大模型的能力；了解向量数据库的原理与应用。 后端开发：熟练使用SpringBoot、SpringCloud微服务架构及其常用组件，熟悉服务网格、分布式事务、配置管理；熟悉MySQL（索引、事务、分库分表、读写分离）、Redis（数据结构、分布式锁）、RabbitMQ（消息可靠性保证、顺序性保障机制）等中间件的原理与应用。 部署与运维：掌握Docker技术，了解Kubernetes基础；拥有使用Jenkins实施CI/CD的经验；了解监控告警技术（ Prometheus + Grafana）。 编程基础：掌握JVM的内存分析、垃圾回收机制、GC调优、性能监控；掌握多线程并发编程、常用数据结构和算法及设计模式；熟悉网络基础（TCP/IP, HTTP/HTTPS）。 💻项目经历 # 一、智能餐饮推荐与服务系统个人开发项目2023.04 - 至今 项目描述：整合外卖与点评业务，基于大语言模型构建智能餐饮平台，实现智能推荐、客服自动化和评价分析三大模块，新用户首单转化率提升18%，客服人工干预率下降70%，用户投诉响应时效缩短至10分钟内。\n使用技术：\n后端框架：SpringBoot + MySQL + MongoDB + Redis + RabbitMQ AI框架：LangChain4J + Qwen-1.8B + Chroma + 通义千问 API 部署与运维：Docker + Nginx 工作亮点：\n智能推荐模块：基于LangChain4J设计用户行为-菜品特征双向量模型，复购率提升25%；实现基于地域特征的冷启动方案，新用户首单转化率提高18%。 智能客服模块：调用通义千问API实现常见问题自动应答（如 “退款流程”“配送范围”），设计并优化了多轮对话的Prompt，客服人工干预率降低70%。 智能评价模块：使用本地部署大模型支撑评价情感分析，提取 “菜品不新鲜”“配送超时” 等关键词，推送商家告警，用户投诉响应时效从2小时缩至10分钟。 高并发架构优化：对Qwen-1.8B采用4-bit量化部署，显存占用从8GB降至2.5GB，推理响应时间从800ms优化至400ms，支撑高峰期每秒30+大模型请求稳定处理；基于Sharding-JDBC对订单表水平分片，查询性能提升40%；设计Redis分布式锁 + RabbitMQ异步通信架构，订单创建耗时从500ms降至150ms。 二、分布式云监控与智能运维平台个人开发项目2024.04 - 至今 项目描述：一站式云资源监控与运维平台，构建RAG运维知识库，解决分布式环境下运维效率低下的问题。可同时监控300+节点，故障处理效率提升40%，服务可用性达99.9%。\n使用技术：\n后端框架：SpringBoot + SpringCloud + MySQL + Redis + Netty + Prometheus + Grafana 消息队列：RabbitMQ（日志处理） + Pulsar（实时监控指标） 日志系统：ELK（Elasticsearch + Logstash + Kibana） AI框架：LangChain4J + Qwen-7B-Chat + Milvus + Sentence-BERT 权限控制：JWT + HTTPS 工作亮点：\n智能运维助手：构建基于RAG的智能问答系统，将运维手册、故障案例文档按512-token粒度切片，使用sentence-transformers生成768维向量存入Milvus数据库；基于LangChain4J集成本地部署的Qwen-7B-Chat大模型，实现语义检索与生成；支持自然语言提问，检索准确率达85%，故障处理效率提升40%。 监控告警与日志系统：基于Prometheus自定义Exporter采集服务器基础指标，配合Grafana构建多维度监控大盘，支持自定义告警规则；设置分级告警机制；通过Logback AsyncAppender异步发送日志到RabbitMQ，使用Logstash解析并写入Elasticsearch，实现日志快速检索，问题定位效率提升60%以上。 系统安全与优化：基于Netty自定义协议实现高性能数据接收端，支持百万级并发连接；结合Pulsar消息队列实现削峰填谷，应对海量监控指标上报；使用Redis缓存热点监控数据，LRU淘汰策略保证稳定运行；实现基于JWT的RBAC权限控制与HTTPS双向认证；设计统一错误码规范与结构化日志格式，便于后期排查问题。 👩‍💻自我评价 # 技术复合能力：具备扎实的后端开发功底与系统架构思维，并对大模型应用开发有浓厚的兴趣和项目实践，善于将工程化思维应用于AI场景。 持续学习能力：学习与适应能力强，能够快速钻研并掌握新技术，并成功将其落地于项目中（如智能餐饮系统、运维问答助手）。 团队协作能力：做事认真踏实，有责任心，具备良好的团队协作精神和沟通能力，渴望在优秀的业务团队中贡献技术力量并快速成长。 ","date":"2025年11月24日","externalUrl":null,"permalink":"/resume/","section":"个人简历","summary":"","title":"个人简历","type":"resume"},{"content":"专注于分布式系统设计、中间件性能优化、云计算和大模型应用相关领域的学习和分享。 ","date":"2025年11月24日","externalUrl":null,"permalink":"/","section":"永远天真烂漫","summary":"","title":"永远天真烂漫","type":"page"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/mysql/","section":"Tags","summary":"","title":"MySQL","type":"tags"},{"content":" 引言 # 在这里写文章的引言内容\u0026hellip;\n正文 # 在这里写文章的主要内容\u0026hellip;\n总结 # 在这里写文章的总结\u0026hellip;\n","date":"2025年11月24日","externalUrl":null,"permalink":"/posts/mysql01/","section":"全部文章","summary":"","title":"MySQL 基础 - 01","type":"posts"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/posts/","section":"全部文章","summary":"","title":"全部文章","type":"posts"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"Tags","summary":"","title":"数据库","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/categories/database/","section":"Categories","summary":"","title":"数据库基础","type":"categories"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/categories/distributed/","section":"Categories","summary":"","title":"分布式系统","type":"categories"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"分布式系统是现代软件架构的重要组成部分，本文将介绍分布式系统设计的核心原则和实践方法。\nCAP 理论 # CAP 理论是分布式系统设计的基础理论之一，它指出分布式系统无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）三个特性。\n在实际应用中，由于网络分区是不可避免的，系统设计者必须在一致性和可用性之间做出权衡。不同的应用场景需要不同的选择策略。\n例如，金融系统通常选择强一致性，而社交网络则可以接受最终一致性以获得更好的可用性。\n一致性模型 # 在分布式系统中，一致性是一个关键问题。常见的一致性模型包括强一致性、最终一致性、因果一致性等。\n强一致性保证所有节点在任何时刻看到的数据都是一致的，但会牺牲系统的可用性和性能。最终一致性则允许短时间的不一致，但保证最终会达到一致状态。\n选择合适的一致性模型需要根据业务需求、性能要求和系统复杂度来综合考虑。\n分布式事务 # 分布式事务是分布式系统中的难题之一。传统的两阶段提交（2PC）协议虽然能保证事务的ACID特性，但存在性能问题和单点故障风险。\n现代分布式系统通常采用补偿事务（Saga）、TCC（Try-Confirm-Cancel）等柔性事务方案，在保证业务最终一致性的同时，获得更好的性能和可用性。\n总结 # 分布式系统设计需要在一致性、可用性和分区容错性之间做出权衡。理解CAP理论、掌握各种一致性模型和事务处理方案，是构建高质量分布式系统的基础。\n","date":"2025年1月20日","externalUrl":null,"permalink":"/posts/distributed01/","section":"全部文章","summary":"","title":"分布式系统设计实践","type":"posts"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"架构设计","type":"tags"},{"content":"","date":"2025年1月18日","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"Kubernetes","type":"tags"},{"content":"","date":"2025年1月18日","externalUrl":null,"permalink":"/categories/cloud/","section":"Categories","summary":"","title":"云计算","type":"categories"},{"content":"","date":"2025年1月18日","externalUrl":null,"permalink":"/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/","section":"Tags","summary":"","title":"云计算","type":"tags"},{"content":"","date":"2025年1月18日","externalUrl":null,"permalink":"/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/","section":"Tags","summary":"","title":"云原生","type":"tags"},{"content":"云原生架构是云计算时代的重要技术趋势，本文将介绍云原生架构的核心概念和演进过程。\n什么是云原生 # 云原生是一种构建和运行应用程序的方法，充分利用云计算的优势。云原生应用程序设计用于在云平台上运行，具有高可用性、可扩展性和弹性。\n云原生的核心理念包括：微服务架构、容器化、持续集成/持续部署（CI/CD）、DevOps文化等。这些理念共同构成了现代应用开发的最佳实践。\n容器化技术 # Docker 和 Kubernetes 是云原生的核心技术。Docker 提供了应用程序的打包和隔离机制，而 Kubernetes 则提供了容器编排和管理能力。\n通过容器技术，开发者可以将应用程序及其依赖打包成一个独立的单元，确保在不同环境中的一致性。Kubernetes 则负责自动化部署、扩展和管理这些容器化应用。\n容器化带来的优势包括：快速部署、环境一致性、资源高效利用、易于扩展等。这些特性使得容器成为云原生应用的基础设施。\n微服务架构 # 微服务是云原生架构的重要组成部分。相比传统的单体应用，微服务将应用拆分为多个独立的小服务，每个服务负责特定的业务功能。\n微服务架构的优势包括：独立部署、技术栈灵活、故障隔离、团队自治等。但同时也带来了分布式系统的复杂性，需要处理服务发现、负载均衡、熔断降级等问题。\n总结 # 云原生架构代表了应用开发和部署的未来方向。通过采用云原生技术和实践，企业可以构建更加灵活、可靠和高效的应用系统。\n","date":"2025年1月18日","externalUrl":null,"permalink":"/posts/cloud01/","section":"全部文章","summary":"","title":"云原生架构演进","type":"posts"},{"content":"","date":"2025年1月15日","externalUrl":null,"permalink":"/tags/ai/","section":"Tags","summary":"","title":"AI","type":"tags"},{"content":"","date":"2025年1月15日","externalUrl":null,"permalink":"/tags/llm/","section":"Tags","summary":"","title":"LLM","type":"tags"},{"content":"","date":"2025年1月15日","externalUrl":null,"permalink":"/categories/llm/","section":"Categories","summary":"","title":"大模型","type":"categories"},{"content":"","date":"2025年1月15日","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"大模型","type":"tags"},{"content":"大语言模型（LLM）正在改变软件开发的方式，本文将介绍如何开发基于大模型的应用，以及相关的最佳实践。\n大模型基础 # 大语言模型是基于Transformer架构的深度学习模型，通过在海量文本数据上预训练，获得了强大的自然语言理解和生成能力。\n当前主流的大模型包括GPT系列、Claude、文心一言等。这些模型可以完成文本生成、问答、翻译、代码生成等多种任务。\n理解大模型的能力边界和局限性是开发应用的前提。大模型虽然强大，但也存在幻觉、知识过时、推理能力有限等问题。\nPrompt Engineering # Prompt Engineering（提示词工程）是使用大模型的关键技能。一个好的提示词可以显著提升模型的输出质量。\n设计提示词的技巧包括：明确任务目标、提供示例（Few-shot Learning）、分步骤引导、使用思维链（Chain of Thought）等方法。\n此外，还需要注意提示词的长度控制、上下文管理、输出格式约束等细节问题。\n实战案例 # 构建一个智能问答系统需要考虑多个方面：知识库构建、向量检索、提示词设计、结果验证等。\n首先需要准备领域知识，将其转换为向量存储。当用户提问时，通过语义检索找到相关知识，组合成上下文，然后让大模型基于这些信息回答问题。\n这种RAG（检索增强生成）模式可以有效减少模型幻觉，提供更准确和可靠的答案。\n总结 # 大模型应用开发需要深入理解模型能力、掌握提示词工程技巧、合理设计系统架构。随着技术的发展，大模型将在更多领域发挥重要作用。\n","date":"2025年1月15日","externalUrl":null,"permalink":"/posts/llm01/","section":"全部文章","summary":"","title":"大模型应用开发实战","type":"posts"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/rabbitmq/","section":"Tags","summary":"","title":"Rabbitmq","type":"tags"},{"content":"Redis 是最常用的缓存中间件之一，本文将分享 Redis 性能优化的实践经验。\n数据结构选择 # 选择合适的数据结构对性能至关重要\u0026hellip;\n持久化策略 # 合理配置 RDB 和 AOF\u0026hellip;\n集群方案 # Redis Cluster 和哨兵模式\u0026hellip;\n","date":"2025年1月12日","externalUrl":null,"permalink":"/posts/middleware-rabbitmq01/","section":"全部文章","summary":"","title":"RabbitMQ 性能优化实践","type":"posts"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/redis/","section":"Tags","summary":"","title":"Redis","type":"tags"},{"content":"Redis 是最常用的缓存中间件之一，本文将分享 Redis 性能优化的实践经验。\n数据结构选择 # 选择合适的数据结构对性能至关重要\u0026hellip;\n持久化策略 # 合理配置 RDB 和 AOF\u0026hellip;\n集群方案 # Redis Cluster 和哨兵模式\u0026hellip;\n","date":"2025年1月12日","externalUrl":null,"permalink":"/posts/middleware-redis01/","section":"全部文章","summary":"","title":"Redis 性能优化实践","type":"posts"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","section":"Tags","summary":"","title":"性能优化","type":"tags"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/categories/middleware/","section":"Categories","summary":"","title":"中间件","type":"categories"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/","section":"Tags","summary":"","title":"中间件","type":"tags"},{"content":"索引是数据库性能优化的关键，本文将介绍 MySQL 索引优化的方法。\n索引类型 # B+树索引、哈希索引、全文索引\u0026hellip;\n索引设计原则 # 如何设计高效的索引\u0026hellip;\n慢查询优化 # 使用 EXPLAIN 分析查询性能\u0026hellip;\n","date":"2025年1月10日","externalUrl":null,"permalink":"/posts/mysql02/","section":"全部文章","summary":"","title":"MySQL 索引优化指南","type":"posts"},{"content":"","date":"2025年1月10日","externalUrl":null,"permalink":"/tags/%E7%B4%A2%E5%BC%95/","section":"Tags","summary":"","title":"索引","type":"tags"},{"content":"","date":"2021年1月10日","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"Java 高级主题：多线程编程、Lambda表达式、网络编程、日志和调试、单元测试、设计模式、Java8新特性、Java17新特性、Java21新特性。\n多线程编程 # 线程创建方式 # 继承Thread类，任务与线程耦合度高 实现Runnable接口，任务与线程解耦，支持多个线程执行同一任务。 实现Callable接口，支持返回值，可以抛出异常，配合Future使用，适合需要结果的任务。 使用线程池 Future接口：表示异步计算的结果，提供了检查计算是否完成、等待计算完成并获取结果的方法。 FutureTask类：实现了Future接口，用于执行Callable任务，支持取消任务、查询任务是否完成、获取任务执行结果等操作。 CompletableFuture类：提供了异步编程的能力，支持组合多个异步任务，处理任务完成后的回调，以及异常处理，支持链式调用、组合操作、异常处理等功能，提供了丰富的异步编程api。 同步机制 # 在多线程环境下，同步机制是确保数据一致性和避免竞态条件的关键。\n同步机制 特点 适用场景 性能影响 锁 简单易用，适用于简单场景 对共享资源进行互斥访问 高 synchronized关键字 内置锁，可重入，自动加锁和解锁，适用于简单场景 简单的同步需求 中等 volatile关键字 确保变量的可见性，禁止指令重排序 简单状态标记，对共享变量的简单读写操作 低 ReentrantLock类 显式锁，功能丰富，可重入锁，支持公平锁和非公平锁，适用于复杂场景 对共享资源进行互斥访问，需要更高级的同步控制，复杂的锁控制 中等 ReadWriteLock接口 读写分离锁，允许多个线程同时读取共享资源，但是只允许一个线程写入共享资源 读多写少场景，对共享资源进行读写操作，读操作可以并发执行，写操作互斥执行 低（读操作） Atomic类 提供原子操作，避免竞态条件，无锁 简单的原子更新，对共享变量的简单读写操作，需要原子性操作 很低 信号量 控制同时访问资源的线程数量 对共享资源进行限流 中 条件变量 线程等待某个条件满足后再继续执行 线程之间协调工作 低 线程池详解 # 线程池是一种管理和复用线程的机制，它可以避免线程创建和销毁的开销，提高系统的性能和响应速度。 线程池的主要组成部分包括：\n线程池管理器：负责创建、销毁线程池，以及管理线程池中的线程。 工作线程：线程池中的线程，用于执行任务。 任务队列：用于存储待执行的任务，当工作队列为空时，工作线程会等待新任务的到达。 任务接口：定义了任务的执行方法，所有任务都必须实现这个接口。 线程工厂：用于创建新的线程，线程池可以使用不同的线程工厂来创建线程，例如使用默认线程工厂或自定义线程工厂。 拒绝策略：当任务队列已满且无法接受新任务时，线程池会调用拒绝策略来处理这个问题，例如抛出异常、拒绝新任务或调用其他策略。 核心参数\n核心线程数（corePoolSize）：线程池中的最小线程数量，即使这些线程是空闲的，也会保留在线程池中的线程数量。 最大线程数（maximumPoolSize）：线程池中的最大线程数量，当任务队列已满且无法接受新任务时，线程池会创建新的线程，直到线程数量达到最大线程数。 线程keepAliveTime（线程保持活动时间）：当线程池中的线程数量大于核心线程数时，多余的线程会在保持活动时间内等待新任务的到达。如果超过了保持活动时间，多余的线程会被销毁。 任务队列（workQueue）：用于存储待执行的任务，当工作队列为空时，工作线程会等待新任务的到达。 线程工厂（threadFactory）：用于创建新的线程，线程池可以使用不同的线程工厂来创建线程，例如使用默认线程工厂或自定义线程工厂。 拒绝策略（rejectedExecutionHandler）：当任务队列已满且无法接受新任务时，线程池会调用拒绝策略来处理这个问题，例如抛出异常、拒绝新任务或调用其他策略。 线程池的工作原理如下：\n当任务到达时，线程池管理器会判断线程池是否已满。 如果线程池未满，线程池管理器会创建一个新的工作线程来执行任务。 如果线程池已满，任务会被加入任务队列中等待执行。 当工作队列为空时，工作线程会等待新任务的到达。 当工作线程空闲时，会从任务队列中取出任务来执行。 如果线程池中的线程数量超过了核心线程数，多余的线程会在保持活动时间内等待新任务的到达。如果超过了保持活动时间，多余的线程会被销毁。 当线程池中的线程数量等于核心线程数时，新任务会被加入任务队列中等待执行。 如果任务队列已满，线程池会调用拒绝策略来处理这个问题。 线程池的状态：线程池有以下几种状态：运行状态、关闭状态、终止状态、等待状态。\npublic enum ThreadPoolState { RUNNING, // 运行状态 SHUTDOWN, // 关闭状态 TERMINATED, // 终止状态 WAITING, // 等待状态 BLOCKED // 阻塞状态 } //ThreadPoolExecutor类 public class ThreadPoolExecutor extends AbstractExecutorService { // 核心线程数 private final int corePoolSize; // 最大线程数 private final int maximumPoolSize; // 线程保持活动时间 private final long keepAliveTime; // 任务队列 private final BlockingQueue\u0026lt;Runnable\u0026gt; workQueue; // 线程工厂 private final ThreadFactory threadFactory; // 拒绝策略 private final RejectedExecutionHandler rejectedExecutionHandler; } //创建自定义线程池 // 自定义线程池 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( corePoolSize, // 核心线程数 maximumPoolSize, // 最大线程数 keepAliveTime, // 线程保持活动时间 TimeUnit.SECONDS, // 时间单位 workQueue, // 任务队列 threadFactory, // 线程工厂 rejectedExecutionHandler // 拒绝策略 ); // 提交任务 threadPoolExecutor.submit(() -\u0026gt; { // 任务逻辑 System.out.println(\u0026#34;任务逻辑\u0026#34;); }); // 关闭线程池 threadPoolExecutor.shutdown(); 性能问题 # 线程数量过多导致上下文切换开销 锁竞争激烈影响并发性能 内存可见性问题导致的性能损失 不合理的任务分配策略 资源泄漏和死锁问题 优化策略 # 合理设置线程数：cpu密集型任务使用cpu核心数，io密集型可以适当增加线程数 减少锁竞争：使用读写锁、分段锁等技术 选择合适的数据结构：使用ConcurrentHashMap等并发容器； 避免伪共享：合理设计数据结构布局 监控和调优：使用jvm工具监控线程状态。 Lambda表达式 # Lambda表达式是Java8引入的一种函数式编程的语法，用于简化匿名内部类的使用。它允许我们将行为作为参数传递，从而实现更灵活的编程。\nLambda表达式的基本语法如下：\n(parameters) -\u0026gt; expression 或者\n(parameters) -\u0026gt; { statements; } // 示例：使用Lambda表达式实现Runnable接口 Runnable runnable = () -\u0026gt; System.out.println(\u0026#34;Lambda表达式实现Runnable接口\u0026#34;); // 示例：使用Lambda表达式实现Comparator接口 Comparator\u0026lt;Integer\u0026gt; comparator = (a, b) -\u0026gt; a.compareTo(b); 其中，parameters是参数列表，expression是一个表达式，statements是一个语句块。Lambda表达式可以用于函数式接口的实现，例如Runnable、Callable、Comparator等。\n替代匿名内部类\n//传统匿名内部类 Runnable oldWay = new Runnable() { @Override public void run() { System.out.println(\u0026#34;传统匿名内部类实现Runnable接口\u0026#34;); } }; // 使用Lambda表达式实现Runnable接口 Runnable newWay = () -\u0026gt; System.out.println(\u0026#34;Lambda表达式实现Runnable接口\u0026#34;); Lambda表达式的优势在于代码更加简洁，同时也提高了代码的可读性和维护性。\n函数式接口是指只包含一个抽象方法的接口，例如Runnable、Callable、Comparator等。Lambda表达式可以直接实现函数式接口，而不需要显式地定义一个匿名内部类。\n示例：使用Lambda表达式实现Comparator接口\n@FunctionalInterface interface Calculator { int calculate(int a, int b); } // 示例：使用Lambda表达式实现Calculator接口 Calculator add = (a, b) -\u0026gt; a + b; Calculator subtract = (a, b) -\u0026gt; a - b; int result1 = add.calculate(5, 3); // 8 int result2 = subtract.calculate(5, 3); // 2 常用函数式接口 # 接口名称 方法签名 用途 示例 Runnable void run() 表示一个无参数、无返回值的操作 () -\u0026gt; System.out.println(\u0026ldquo;Lambda表达式实现Runnable接口\u0026rdquo;) Callable V call() throws Exception 表示一个有参数、有返回值的操作 (a, b) -\u0026gt; a + b Comparator int compare(T o1, T o2) 表示一个用于比较两个对象的函数 (a, b) -\u0026gt; a.compareTo(b) Predicate boolean test(T t) 表示一个用于测试一个对象是否满足某种条件的函数 (a) -\u0026gt; a \u0026gt; 0 Function R apply(T t) 表示一个用于将一个对象转换为另一个对象的函数 (a) -\u0026gt; a.toString() Supplier T get() 表示一个用于提供一个对象的函数 () -\u0026gt; new Random().nextInt() Consumer void accept(T t) 表示一个用于消费一个对象的函数 (a) -\u0026gt; System.out.println(a) UnaryOperator T apply(T t) 表示一个用于对一个对象进行操作并返回相同类型对象的函数 (a) -\u0026gt; a * 2 BinaryOperator T apply(T t1, T t2) 表示一个用于对两个对象进行操作并返回相同类型对象的函数 (a, b) -\u0026gt; a + b 方法引用 # 方法引用是Java8引入的一种新的语法，用于简化Lambda表达式的使用。它允许我们直接引用一个已存在的方法，而不需要显式地定义一个Lambda表达式。\n方法引用的基本语法如下：\nClassName::methodName 或者\nobject::methodName 其中，ClassName是类名，object是一个对象实例，methodName是方法名。\n示例：使用方法引用实现Comparator接口\n// 示例：使用方法引用实现Comparator接口 Comparator\u0026lt;Integer\u0026gt; comparator = Integer::compareTo; 方法引用的优势在于代码更加简洁，同时也提高了代码的可读性和维护性。\n//方法引用示例 List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;); //Lambda表达式示例 names.forEach(name -\u0026gt; System.out.println(name)); //方法引用示例 names.forEach(System.out::println); //静态方法引用 List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;) .stream() .map(Integer::parseInt)//定价于s -\u0026gt; Integer.parseInt(s) .collect(Collectors.toList()); //构造器引用 Supplier\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; listSupplier = ArrayList::new; List\u0026lt;String\u0026gt; newList = listSupplier.get(); Stream API应用 # Stream API是Java8引入的一种新的函数式编程的API，用于对集合进行操作。它允许我们以一种声明式的方式来处理集合数据，而不需要显式地编写循环和条件语句。\n// 示例：使用Stream API对集合进行操作 List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream() .filter(n -\u0026gt; n % 2 == 0) // 过滤出偶数 .mapToInt(Integer::intValue) // 将整数转换为int类型 .sum(); // 对偶数进行求和 System.out.println(sum); // 6 // 示例：使用Stream API对集合进行操作 List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;); names.stream() .filter(name -\u0026gt; name.startsWith(\u0026#34;A\u0026#34;)) // 过滤出以\u0026#34;A\u0026#34;开头的姓名 .forEach(System.out::println); // 打印符合条件的姓名 //分组统计 // 示例：使用Stream API对集合进行分组统计 Map\u0026lt;Boolean, List\u0026lt;Integer\u0026gt;\u0026gt; evenOddMap = numbers.stream() .collect(Collectors.partitioningBy(n -\u0026gt; n % 2 == 0)); // 按偶数和奇数分组 System.out.println(evenOddMap); // {false=[1, 3, 5], true=[2, 4]} 网络编程 # 网络编程是指编写能够在网络上进行数据通信的数据。网络编程的核心是Socket(套接字)，它是网络通信的端点。\nSocket基本概念：网络通信的基础，包含ip地址和端口号，支持tcp和udp协议，提供双向数据传输。 客户端/服务器模型：服务器被动等待连接，客户端主动发起连接，支持多客户端连接，可以双向通信。 TCP Socket编程 # TCP（传输控制协议） Socket编程是指使用TCP协议进行网络通信的编程。TCP协议是一种可靠的、面向连接的协议，它确保数据在传输过程中不会丢失或损坏。\nTCP Socket编程流程：服务器创建Socket对象，绑定端口号，监听连接请求；客户端创建Socket对象，连接服务器；双方通过输入输出流进行数据通信；通信结束后关闭Socket连接。 示例：使用TCP Socket编程实现简单的客户端/服务器通信\n// 服务器端代码 ServerSocket serverSocket = new ServerSocket(8888); Socket socket = serverSocket.accept(); InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); // 客户端代码 Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8888); InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); UDP Socket编程 # UDP（用户数据报协议） Socket编程是指使用UDP协议进行网络通信的编程。UDP协议是一种不可靠的、无连接的协议，它不确保数据在传输过程中不会丢失或损坏。\nUDP Socket编程流程：服务器创建DatagramSocket对象，绑定端口号；客户端创建DatagramSocket对象；双方通过DatagramPacket对象进行数据通信；通信结束后关闭DatagramSocket连接。 示例：使用UDP Socket编程实现简单的客户端/服务器通信 // 服务器端代码 DatagramSocket serverSocket = new DatagramSocket(8888); byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); serverSocket.receive(packet); String message = new String(packet.getData(), 0, packet.getLength()); System.out.println(\u0026#34;服务器端收到消息：\u0026#34; + message); // 客户端代码 DatagramSocket clientSocket = new DatagramSocket(); byte[] buffer = \u0026#34;Hello, Server!\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(\u0026#34;localhost\u0026#34;), 8888); clientSocket.send(packet); TCP和UDP对比 # TCP协议：可靠、面向连接、确保数据传输不丢失或损坏。保证数据顺序，头部开销20字节，适用于文件传输、网页浏览、邮件。 UDP协议：不可靠、无连接、不确保数据传输不丢失或损坏。不保证数据顺序，头部开销8字节，适用于实时通信、视频会议、在线游戏等场景。 高级网络编程技术 # 使用线程池创建多线程服务器\n// 服务器端代码 public class ThreadPoolServer{ private static final int THREAD_POOL_SIZE = 10; private static final int PORT = 8888; public static void main(String[] args){ // 创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE); try{ ServerSocket serverSocket = new ServerSocket(PORT); while(true){ Socket socket = serverSocket.accept(); // 每个客户端连接都创建一个新线程处理，将客户端处理任务提交给线程池 executorService.submit(new ClientTask(socket)); } }catch(IOException e){ e.printStackTrace(); }finally{ // 关闭线程池 executorService.shutdown(); } } } class ClientTask implements Runnable{ private Socket clientSocket; public ClientTask(Socket socket){ this.clientSocket = socket; } @Override public void run(){ try(InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream()){ // 处理客户端请求 }catch(IOException e){ e.printStackTrace(); } } } 练习建议 # 结合tcp socket和多线程技术，实现一个简单的聊天室应用，支持多用户同时在线聊天。 结合udp socket技术，实现一个简单的文件传输应用，支持客户端上传文件到服务器。 使用NIO(非阻塞IO)技术，可以进一步提高网络应用的性能和并发处理能力。 日志和调试 # 日志框架：如log4j、slf4j、logback等，用于记录应用程序运行时的日志信息，帮助开发人员定位和解决问题。 调试工具：如Eclipse、IntelliJ IDEA等，提供断点调试、变量查看、线程分析等功能，帮助开发人员快速定位和修复问题。 java.util.logging(JUL) # jdk内置，无需额外依赖 配置简单，适合小型项目 性能较好，资源占用少 支持多种日志级别 ：如SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST等，开发人员可以根据需要选择不同的日志级别记录日志信息。 Logger logger = Logger.getLogger(MyClass.class.getName()); logger.warning(\u0026#34;这是一条WARNING日志\u0026#34;); logger.info(\u0026#34;这是一条INFO日志\u0026#34;); Log4j2 # 功能强大，配置灵活，支持多种日志输出目标（如控制台、文件、数据库等） 性能优秀，能够处理大规模日志记录场景 提供丰富的日志过滤和格式化功能，开发人员可以根据需要自定义日志输出格式 支持日志滚动和归档，避免日志文件过大导致性能问题 支持异步日志记录，提高应用程序性能 提供插件机制，开发人员可以根据需要扩展Log4j2的功能 配置简单，开发人员可以通过XML或JSON配置文件进行配置 支持日志上下文传递，开发人员可以在日志中添加自定义的上下文信息，方便问题定位和分析 // 引入Log4j2依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.14.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; // 配置Log4j2 \u0026lt;configuration\u0026gt; \u0026lt;appenders\u0026gt; \u0026lt;console name=\u0026#34;console\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\u0026#34;/\u0026gt; \u0026lt;/console\u0026gt; \u0026lt;/appenders\u0026gt; \u0026lt;loggers\u0026gt; \u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;console\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/loggers\u0026gt; \u0026lt;/configuration\u0026gt; // 在代码中使用Log4j2 import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class MyClass{ private static final Logger logger = LogManager.getLogger(MyClass.class); public void doSomething(){ logger.info(\u0026#34;这是一条INFO日志\u0026#34;); } } SLF4J + Logback # 功能强大，配置灵活，支持多种日志输出目标（如控制台、文件、数据库等） 性能优秀，能够处理大规模日志记录场景 提供丰富的日志过滤和格式化功能，开发人员可以根据需要自定义日志输出格式 支持日志滚动和归档，避免日志文件过大导致性能问题 支持异步日志记录，提高应用程序性能 提供插件机制，开发人员可以根据需要扩展Logback的功能 配置简单，开发人员可以通过XML或Groovy配置文件进行配置，与springboot完美集成，社区活跃。 支持日志上下文传递，开发人员可以在日志中添加自定义的上下文信息，方便问题定位和分析 // 引入SLF4J和Logback依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.32\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; // 配置Logback \u0026lt;configuration\u0026gt; \u0026lt;appenders\u0026gt; \u0026lt;console name=\u0026#34;console\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\u0026#34;/\u0026gt; \u0026lt;/console\u0026gt; \u0026lt;/appenders\u0026gt; \u0026lt;loggers\u0026gt; \u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;console\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/loggers\u0026gt; \u0026lt;/configuration\u0026gt; // 在代码中使用SLF4J + Logback import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class MyClass{ private static final Logger logger = LoggerFactory.getLogger(MyClass.class); public void doSomething(){ logger.info(\u0026#34;这是一条INFO日志\u0026#34;); } } 日志级别和配置 # 级别 说明 使用场景 示例 TRACE 跟踪信息，用于记录应用程序的详细运行信息 应用程序需要记录详细运行信息时(诊断问题时的详细跟踪) logger.trace(\u0026ldquo;这是一条TRACE日志\u0026rdquo;); DEBUG 调试信息，用于记录应用程序的调试信息 应用程序需要记录调试信息时（开发和测试阶段） logger.debug(\u0026ldquo;这是一条DEBUG日志\u0026rdquo;); INFO 一般信息，用于记录应用程序运行时的重要事件 应用程序正常运行时记录关键事件 logger.info(\u0026ldquo;这是一条INFO日志\u0026rdquo;); WARNING 警告信息，可能会影响应用程序正常运行 应用程序遇到非严重问题 logger.warning(\u0026ldquo;这是一条WARNING日志\u0026rdquo;); ERROR 错误信息，影响应用程序正常运行 应用程序遇到无法处理的异常情况 logger.error(\u0026ldquo;这是一条ERROR日志\u0026rdquo;); FATAL 致命错误，影响应用程序正常运行 应用程序遇到无法处理的异常情况 logger.fatal(\u0026ldquo;这是一条FATAL日志\u0026rdquo;); 调试技巧 # 断点调试：在关键位置设置断点，逐步执行代码 条件断点：在断点上设置条件，只有满足条件时才会触发断点，方便定位问题 日志调试：在代码中添加日志语句，记录变量值、方法调用等信息，帮助定位问题 监视表达式：在调试过程中，监视表达式可以实时显示变量的值，帮助开发人员定位问题 调用栈分析：在调试过程中，调用栈分析可以帮助开发人员定位问题所在的方法调用链，方便问题定位和解决。 异常断点：在调试过程中，设置异常断点可以在应用程序抛出异常时自动触发断点，方便定位问题。 远程调试：在应用程序运行在远程服务器上时，开发人员可以使用远程调试功能连接到服务器进行调试，方便问题定位和解决。 日志框架选择 # Log4j2：功能强大，配置灵活，支持多种日志输出目标（如控制台、文件、数据库等），性能优秀，能够处理大规模日志记录场景。 SLF4J + Logback：功能强大，配置灵活，支持多种日志输出目标（如控制台、文件、数据库等），性能优秀，能够处理大规模日志记录场景。 其他日志框架：如Log4j、Logback等，也提供了丰富的功能和配置选项，开发人员可以根据需要选择合适的日志框架。 实践指南 # //使用参数化日志，避免字符串拼接 // 错误示例 logger.info(\u0026#34;用户\u0026#34; + userId + \u0026#34;登录失败\u0026#34;); // 正确示例 logger.info(\u0026#34;用户{}登录失败\u0026#34;, userId); //记录异常的完整信息 // 错误示例 logger.error(\u0026#34;发生异常\u0026#34;, e); // 正确示例 logger.error(\u0026#34;处理请求失败：{}\u0026#34;, e.getMessage(), e); //使用合适的日志级别 logger.debug(\u0026#34;计算结果：{}\u0026#34;, result); logger.warn(\u0026#34;用户{}未授权\u0026#34;, username); 使用异步日志减少对主线程的影响 设置合理的日志级别，避免不必要的日志输出 使用参数化日志，避免字符串拼接的性能开销 定期清理和归档日志文件 在生产环境中关闭DEBUG级别日志 生产环境推荐info级别的日志 java中常用的日志门面是slf4j。 日志输出目标 # 控制台：将日志输出到命令行窗口，方便开发人员查看和调试。ConsoleAppender 文件：将日志输出到文件中，方便长期存储和分析。FileAppender 数据库：将日志输出到数据库中，方便集中管理和查询。DatabaseAppender 远程服务器：将日志输出到远程服务器上，方便分布式系统的日志管理。SocketAppender 日志分析工具：将日志输出到日志分析工具中，如ELK Stack、Graylog等，方便日志的可视化分析和监控。 单元测试 # Junit 5 是java生态系统中最流行的单元测试框架，提高了丰富的注解、断言方法和扩展机制。由三个子项目组成：\nJunit Platform：提供了测试运行器、测试引擎和测试发现机制，用于执行和发现测试用例。 Junit Jupiter：提供了JUnit 5的新特性，如参数化测试、重复测试、条件测试等。 Junit Vintage：提供了对JUnit 3和JUnit 4的支持，使旧版的测试用例可以在JUnit 5中运行。 测试注解 # 注解 说明 使用场景 示例 @Test 用于标识测试方法 测试用例的入口点 @Test void testMethod() { \u0026hellip; } @BeforeEach 在每个测试方法执行前运行 初始化测试环境 @BeforeEach void setUp() { \u0026hellip; } @AfterEach 在每个测试方法执行后运行 清理测试环境 @AfterEach void tearDown() { \u0026hellip; } @BeforeAll 在所有测试方法执行前运行 初始化共享资源，类级别初始化 @BeforeAll void setUpAll() { \u0026hellip; } @AfterAll 在所有测试方法执行后运行 清理共享资源，类级别清理 @AfterAll void tearDownAll() { \u0026hellip; } @DisplayName 为测试方法添加自定义名称 方便阅读和理解测试用例 @DisplayName(\u0026ldquo;测试方法1\u0026rdquo;) void testMethod1() { \u0026hellip; } @Disabled 禁用测试方法 临时禁用测试用例 @Disabled(\u0026ldquo;暂不执行\u0026rdquo;) void testMethod() { \u0026hellip; } @Timeout 设置测试方法的超时时间 防止测试用例运行时间过长 @Timeout(5) void testMethod() { \u0026hellip; } @Tag 为测试方法添加标签 方便根据标签进行筛选和执行 @Tag(\u0026ldquo;fast\u0026rdquo;) void testMethod() { \u0026hellip; } @ParameterizedTest 用于参数化测试 测试方法需要不同参数组合的场景 @ParameterizedTest @ValueSource(ints = {1, 2, 3}) void testMethod(int value) { \u0026hellip; } @RepeatedTest 重复执行测试方法 测试方法需要重复执行的场景 @RepeatedTest(3) void testMethod() { \u0026hellip; } 断言方法 \u0026amp; 参数化测试 # assertEquals：验证两个值是否相等\nassertNotEquals：验证两个值是否不相等\nassertTrue：验证条件是否为真\nassertFalse：验证条件是否为假\nassertThrows：验证是否抛出了指定类型的异常\nassertAll：组合多个断言，确保所有断言都通过\nassertNull：验证对象是否为null\nassertNotNull：验证对象是否不为null\nassertSame：验证两个对象引用是否指向同一个对象\nassertNotSame：验证两个对象引用是否不指向同一个对象\nassertArrayEquals：验证两个数组是否相等\n@ValueSource：为参数化测试提供值来源，如int、long、double、String等\n@EnumSource：为参数化测试提供枚举值来源\n@CsvSource：为参数化测试提供CSV格式的参数来源\n@MethodSource：为参数化测试提供方法引用的参数来源\n// 测试方法示例 /** * 被测试的类 * 计算器类-测试方法示例 * 提供加法、减法、乘法和除法等操作 */ public class Calculator{ /** * 加法运算 */ public int add(int a, int b) { return a + b; } /** * 减法运算 */ public int subtract(int a, int b) { return a - b; } /** * 乘法运算 */ public int multiply(int a, int b) { return a * b; } /** * 除法运算 */ public int divide(int a, int b) { return a / b; } } /** * 测试类-计算器类 * 测试加法、减法、乘法和除法等操作 class CalculatorTest{ private Calculator calculator; @BeforeEach void setUp() { calculator = new Calculator(); System.out.println(\u0026#34;每个测试方法初始化\u0026#34;); } @BeforeAll static void setUpClass(){ System.out.println(\u0026#34;类级别初始化\u0026#34;); } @Test @DisplayName(\u0026#34;测试加法\u0026#34;) void testAdd() { int result = calculator.add(2, 3); assertEquals(5, result); } @Test @DisplayName(\u0026#34;测试减法\u0026#34;) void testSubtract() { assertEquals(2, calculator.subtract(5, 3)); assertNotEquals(3, calculator.subtract(5, 3)); // 测试减法的边界情况 assertEquals(-2, calculator.subtract(3, 5)); } @Test @DisplayName(\u0026#34;测试乘法\u0026#34;) void testMultiply() { assertEquals(12, calculator.multiply(4, 3)); } @Test @DisplayName(\u0026#34;测试除法\u0026#34;) void testDivide() { assertEquals(2, calculator.divide(6, 3)); assertNotEquals(3, calculator.divide(6, 3)); // 测试除法的边界情况 assertEquals(-2, calculator.divide(3, -6)); } @Test @DisplayName(\u0026#34;测试除零异常\u0026#34;) void testDivideByZero() { IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -\u0026gt; calculator.divide(6, 0)); assertEquals(\u0026#34;除数不能为零\u0026#34;, exception.getMessage()); } @Test @DisplayName(\u0026#34;参数化测试加法\u0026#34;) @CsvSource({ \u0026#34;1, 2, 3\u0026#34;, \u0026#34;4, 5, 9\u0026#34;, \u0026#34;7, 8, 15\u0026#34; }) void testAddParameterized(int a, int b, int expected) { assertEquals(expected, calculator.add(a, b)); } @RepeatedTest(3) @DisplayName(\u0026#34;重复测试加法\u0026#34;) void testAddRepeated() { int result = calculator.add(2, 3); assertEquals(5, result); } @Test @Timeout(1) @DisplayName(\u0026#34;测试超时\u0026#34;) void testTimeout() { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } @Nested @DisplayName(\u0026#34;嵌套测试-减法\u0026#34;) class SubtractTest{ @Test @DisplayName(\u0026#34;组合断言测试\u0026#34;) void testSubtract() { assertAll( () -\u0026gt; assertEquals(2, calculator.subtract(5, 3)), () -\u0026gt; assertNotEquals(3, calculator.subtract(5, 3)), () -\u0026gt; assertEquals(-2, calculator.subtract(3, 5)) ); } } } 测试实践 # 测试方法命名清晰描述性 遵循AAA(Arrange-Act-Assert)模式 测试边界条件和异常情况 使用@DisplayName为测试方法添加自定义名称 每个测试只验证一个功能点 每个测试方法独立运行，不依赖其他测试方法 测试方法应该是幂等的，即多次执行结果相同 测试方法应该是快速的，避免耗时的操作 测试方法应该是可重复执行的，避免依赖外部环境 测试方法应该是可维护的，避免重复代码 测试方法应该是可扩展的，方便添加新的测试用例 常用测试类型 # 基本功能测试：验证方法等基本功能是否正确 边界值测试：测试输入参数等边界情况 异常测试：验证异常情况等处理是否正确 参数化测试：使用多组数据验证同一功能 性能测试：验证方法等执行时间是否符合要求 单元测试 集成测试 端到端测试 性能测试 负载测试 压力测试 安全测试 兼容性测试 回归测试 测试覆盖率目标 # 代码覆盖率应该达到80%以上 重点关注核心业务逻辑的测试覆盖 确保所有公共方法都有对应的测试 异常分支和边界条件也要有相应的测试 使用JaCOCO等工具监控测试覆盖率 语句覆盖率：测试是否执行了所有的语句 分支覆盖率：测试是否执行了所有的分支 路径覆盖率：测试是否执行了所有的可能路径 函数覆盖率：测试是否执行了所有的函数 类覆盖率：测试是否执行了所有的类 设计模式 # 设计模式是在软件设计中常见问题的典型解决方案。是解决特定问题的通用概念。\n优势\n提高代码质量和可维护性 促进代码重用和组件化设计 增强系统的可扩展性和灵活性 提供解决常见设计问题的通用解决方案 提供共同的设计语言，便于团队沟通 设计模式分类 # 创建型模式：处理对象创建机制，试图根据实际情况使用合适的方式创建对象。 工厂模式：定义一个创建对象的接口，让子类决定实例化哪个类。 单例模式：确保一个类只有一个实例，并提供一个全局访问点。 原型模式：通过复制现有对象来创建新对象，而不是通过实例化类。 建造者模式：将复杂对象的创建过程分解为多个简单步骤，每个步骤都有一个具体的类负责实现。 抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。 结构型模式：处理对象和类的组合，通过继承和组合来组成更大的结构。 适配器模式：将一个类的接口转换为客户端期望的另一个接口，使不兼容的类能够合作无间。 装饰器模式：动态地给一个对象添加一些额外的职责，而不改变其结构。 外观模式：提供一个统一的接口，隐藏系统的复杂性，使客户端能够更简单地使用系统。 代理模式：为其他对象提供一个代理，以控制对这个对象的访问。 组合模式：将对象组合成树形结构，以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 行为型模式：处理对象之间的通信和职责分配，关注对象如何交互和协作，处理算法和对象间的责任分配。 观察者模式：定义对象之间的一对多依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。 策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 状态模式：允许对象在内部状态改变时改变其行为，对象看起来好像修改了其类。 单例模式（Singleton Pattern） # 定义：确保一个类只有一个实例，并提供一个全局访问点。 优势： 控制实例数量，避免资源浪费 提供全局访问点，方便在不同模块之间共享数据 实现方式： 饿汉式：在类加载时就创建实例，线程安全但可能导致资源浪费 懒汉式：在第一次使用时才创建实例，线程不安全但延迟加载 双重检查锁（Double-Checked Locking）：在懒汉式的基础上添加同步锁，确保线程安全 静态内部类：利用类加载机制实现延迟加载，线程安全 应用场景： 数据库连接池 配置文件读取 日志记录器 线程池 缓存 // 饿汉式：在类加载时就创建实例，线程安全但可能导致资源浪费 public class Singleton { //在类加载时就创建实例 private static final Singleton instance = new Singleton(); // 私有构造方法，防止外部实例化 private Singleton() { } // 提供全局访问点，返回唯一实例 public static Singleton getInstance() { return instance; } } // 懒汉式：在第一次使用时才创建实例，使用synchronized线程安全但延迟加载 public class Singleton { // 延迟加载，在第一次使用时才创建实例（静态实例变量） private static Singleton instance; // 私有构造方法，防止外部实例化 private Singleton() { } // 提供全局访问点，返回唯一实例（线程安全） public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } // 双重检查锁（Double-Checked Locking）：在懒汉式的基础上添加同步锁，确保线程安全 public class Singleton { // 延迟加载，在第一次使用时才创建实例（静态实例变量） //使用volatile确保多线程环境下的可见性 private static volatile Singleton instance; // 私有构造方法，防止外部实例化 private Singleton() { } // 提供全局访问点，返回唯一实例（线程安全） public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } 工厂模式 # 定义：定义一个创建对象的接口，但让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。 优势： 封装了对象的创建过程，客户端无需知道具体的创建细节 符合开闭原则，新增产品时无需修改已有代码 实现方式： 简单工厂模式：将对象的创建集中在一个工厂类中，根据不同的参数返回不同的产品实例 工厂方法模式：定义一个创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。 抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而无需指定具体类。 应用场景： 数据库连接池 配置文件读取 日志记录器 线程池 缓存 // 简单工厂模式：将对象的创建集中在一个工厂类中，根据不同的参数返回不同的产品实例 public interface Shape{ //绘制形状 void draw(); } public class Circle implements Shape{ @Override public void draw() { System.out.println(\u0026#34;绘制一个圆形\u0026#34;); } } public class ShapeFactory{ //根据参数返回不同的产品实例 public Shape createShape(String shapeType){ if(shapeType == null || shapeType.isEmpty()){ return null; } if(shapeType.equals(\u0026#34;circle\u0026#34;)){ return new Circle(); } return null; } } 观察者模式 # 定义：定义对象之间的一对多依赖关系，让多个观察者对象同时监听某一个主题对象，使得每当一个对象改变状态，则所有依赖于它的观察者对象都会得到通知并被自动更新。 优势： 实现了对象之间的松耦合，提高了系统的灵活性和可维护性 符合开闭原则，新增观察者或主题时无需修改已有代码 实现方式： 主题（Subject）：维护一个观察者列表，提供添加、删除和通知观察者的方法 观察者（Observer）：定义一个更新接口，用于接收主题的通知 应用场景： 事件处理系统 消息队列 发布-订阅系统 // 观察者模式：定义对象之间的一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 // 观察者接口 public interface Observer{ //更新方法，当主题状态改变时调用 void update(String news); } //被观察者接口（主题接口） public interface Subject{ //添加观察者 void addObserver(Observer observer); //删除观察者 void removeObserver(Observer observer); //通知所有观察者 void notifyObservers(String news); } // 具体观察者：实现了观察者接口，用于接收主题的通知（新闻机构--具体被观察者） public class NewsAgency implements Subject{ private List observers = new ArrayList\u0026lt;\u0026gt;(); private String latestNews; @Override public void addObserver(Observer observer) { observers.add(observer); System.out.println(\u0026#34;新闻机构添加了一个观察者：\u0026#34; + observer); } @Override public void removeObserver(Observer observer) { observers.remove(observer); System.out.println(\u0026#34;新闻机构删除了一个观察者：\u0026#34; + observer); } @Override public void notifyObservers(String news) { System.out.println(\u0026#34;新闻机构通知所有观察者\u0026#34; + news); for(Observer observer : observers){ observer.update(news); } } //发布新闻 public void publishNews(String news){ this.latestNews = news; notifyObservers(news); } } 策略模式 # 定义：定义一系列算法，将每个算法都封装起来，并使他们可以相互替换，且算法的变化不会影响到使用算法的客户。 优势： 封装了算法的实现细节，符合开闭原则 可以在运行时动态切换算法 实现方式： 定义一个策略接口，包含算法的公共方法 实现不同的策略类，分别封装不同的算法 在上下文类中维护一个策略对象的引用，根据需要切换不同的策略 应用场景： 排序算法 支付方式 压缩算法 //支付策略接口 public interface PaymentStrategy{ //执行支付 void pay(double amount); } //信用卡支付策略 public class CreditCardPayment implements PaymentStrategy{ private String cardNumber; private String cardHolder; public CreditCardPayment(String cardNumber, String cardHolder) { this.cardNumber = cardNumber; this.cardHolder = cardHolder; } @Override public void pay(double amount) { System.out.println(\u0026#34;使用信用卡\u0026#34; + cardNumber + \u0026#34;支付\u0026#34; + amount); } } //支付上下文 public class PaymentContext { private PaymentStrategy paymentStrategy; //设置支付策略 public void setPaymentStrategy(PaymentStrategy paymentStrategy){ this.paymentStrategy = paymentStrategy; } //执行支付 public void pay(double amount){ if(paymentStrategy == null){ throw new IllegalArgumentException(\u0026#34;支付策略不能为空\u0026#34;); } paymentStrategy.pay(amount); } } 最佳实践 # 不要过度设计，只有在真正需要时才使用设计模式 理解问题本质，先理解要解决的问题，再选择合适的设计模式 保持简单：优先选择简单的解决方案 考虑维护性 团队共识（要考虑团队成员的理解能力和技术水平😭） Java8新特性 # Java8是java发展史上的一个重要里程碑，引入了许多革命性的新特性，最重要的是引入了Lambda表达式、Stream API、Optional类、接口默认方法、模块系统等等。\nLambda表达式 # 简化匿名函数的编写，使得代码更加简洁和可读，支持函数式编程风格，减少样板代码，编译器可以更好的优化。\n//传统匿名内部类方式 Comparator\u0026lt;String\u0026gt; comparator = new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String o1, String o2) { return o1.compareTo(o2); } } //Lambda表达式方式 Comparator\u0026lt;String\u0026gt; comparator = (o1, o2) -\u0026gt; o1.compareTo(o2); //方法引用方式 Comparator\u0026lt;String\u0026gt; comparator = String::compareTo; //单参数lambda表达式 List\u0026lt;String\u0026gt; name = Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); name.forEach(name -\u0026gt; System.out.println(name)); name.forEach(System.out::println); Stream API # Stream API 是 Java 8 引入的一个用于处理集合数据的 API，它提供了一系列的流操作（过滤、映射、归约），使得对集合数据的处理更加方便和简洁。Stream 不是数据结构，而是数据源的视图，支持函数式编程风格的操作。\n流操作：流操作是指对流进行的一系列操作，例如过滤、映射、排序、聚合等。 流管道：流管道是指将多个流操作连接起来形成一个管道，每个操作都在管道中进行处理。 并行流：并行流是指利用多核处理器的并行能力，将流操作分布在多个线程中并行处理，提高处理效率。 //流操作 List\u0026lt;String\u0026gt; words = Arrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;); List\u0026lt;String\u0026gt; result = words.stream() .filter(word -\u0026gt; word.length() \u0026gt; 5)//过滤长度大于5的单词 .map(String::toUpperCase)///将单词转换为大写 .sorted()//对单词进行排序 .collect(Collectors.toList());//将结果收集到一个列表中 System.out.println(result); //数值计算 List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream() .filter(n -\u0026gt; n % 2 == 0)//筛选偶数 .mapToInt(Integer::intValue)//将整数转换为int类型 .sum();//对整数进行求和 System.out.println(sum); //分组操作 Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; groupedWords = words.stream() .collect(Collectors.groupingBy(String::length));//根据单词长度分组 System.out.println(groupedWords); Stream只能使用一次，使用后就会关闭 中间操作是有惰性的，只有遇到终端操作才会执行 并行流虽然强大，但不是总是更快，需要根据具体情况选择 避免在Stream中修改外部变量，保持函数式编程的纯净性。 方法引用 # 方法引用是 Lambda 表达式的一种简化形式，它可以直接引用已有的方法，而不需要编写 Lambda 表达式。\n//传统Lambda表达式方式 List\u0026lt;String\u0026gt; name = Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); name.forEach(name -\u0026gt; System.out.println(name)); //方法引用方式 name.forEach(System.out::println); Optional类 # Optional类是一个用于处理空指针异常的类，它可以避免空指针异常的发生。\n空值处理：Optional类可以包装一个可能为空的值，避免直接使用空值导致的空指针异常。 方法链调用：Optional类提供了一系列的方法，例如map、filter、orElse等，使得对可选值的处理更加方便和简洁。 Optional\u0026lt;\u0026gt; optional1 = Optional.of(\u0026#34;hello world\u0026#34;); Optional\u0026lt;\u0026gt; optional2 = Optional.ofNullable(null); Optional\u0026lt;\u0026gt; optional3 = Optional.empty(); //检查值是否存在 if (optional1.isPresent()) { System.out.println(\u0026#34;值存在:\u0026#34; + optional1.get()); } optional1.ifPresent(value -\u0026gt; System.out.println(\u0026#34;值存在:\u0026#34; + value)); //提供默认值 String result1 = optional2.orElse(\u0026#34;默认值\u0026#34;); String result2 = optional3.orElseGet(() -\u0026gt; \u0026#34;默认值\u0026#34;); //链式操作 Optional\u0026lt;String\u0026gt; result = Optional.of(\u0026#34;java programming\u0026#34;) .filter(word -\u0026gt; word.length() \u0026gt; 5)//过滤长度大于5的单词 .map(String::toUpperCase);//将单词转换为大写 .map(s -\u0026gt; \u0026#34;Language:\u0026#34; + s); result.ifPresent(System.out::println); //实际应用场景 public Optional\u0026lt;User\u0026gt; findUserById(String id){ //模拟数据库查询 User user = database.findById(id); return Optional.ofNullable(user); } //安全的链式调用 String email = findUserById(\u0026#34;123\u0026#34;) .map(User::getEmail) .filter(email -\u0026gt; email.contains(\u0026#34;@\u0026#34;)) .orElse(\u0026#34;未找到有效邮箱\u0026#34;); 函数式接口 # 函数式接口是指只包含一个抽象方法的接口，它可以被Lambda表达式引用。\n定义：函数式接口是指只包含一个抽象方法的接口，它可以被Lambda表达式引用。 优势：函数式接口可以使代码更加简洁和可读，支持函数式编程风格，减少样板代码。 应用场景：函数式接口可以用于任何需要传递行为的场景，例如事件处理、回调函数等。 Predicate # Predicate 是一个函数式接口，用于对输入的对象进行判断，返回一个 boolean 值。它通常用于过滤集合中的元素。\nPredicate\u0026lt;\u0026gt; isEmpty = String::isEmpty; //传统方式 List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); List\u0026lt;Integer\u0026gt; evenNumbers = new ArrayList\u0026lt;\u0026gt;(); for (Integer number : numbers) { if (number % 2 == 0) { evenNumbers.add(number); } } //使用Predicate\u0026lt;T\u0026gt; List\u0026lt;Integer\u0026gt; evenNumbers = numbers.stream() .filter(n -\u0026gt; n % 2 == 0)//筛选偶数 .collect(Collectors.toList());//将结果收集到一个列表中 Function\u0026lt;T, R\u0026gt; # Function\u0026lt;T, R\u0026gt; 是一个函数式接口，用于对输入的对象进行转换，返回一个新的对象。它通常用于映射集合中的元素。\nFunction\u0026lt;String, Integer\u0026gt; toLength = String::length; //传统方式 List\u0026lt;String\u0026gt; words = Arrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;java\u0026#34;); List\u0026lt;Integer\u0026gt; lengths = new ArrayList\u0026lt;\u0026gt;(); for (String word : words) { lengths.add(word.length()); } //使用Function\u0026lt;T, R\u0026gt; List\u0026lt;Integer\u0026gt; lengths = words.stream() .map(String::length)//将单词映射为其长度 .collect(Collectors.toList());//将结果收集到一个列表中 Consumer # Consumer 是一个函数式接口，用于对输入的对象进行消费操作，没有返回值。它通常用于对集合中的元素进行操作，例如打印、修改等。\nConsumer\u0026lt;String\u0026gt; print = System.out::println; //传统方式 List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); for (Integer number : numbers) { System.out.println(number); } //使用Consumer\u0026lt;T\u0026gt; numbers.forEach(print); Supplier # Supplier 是一个函数式接口，用于提供一个新的对象实例。它通常用于延迟初始化或创建新对象。\nSupplier\u0026lt;\u0026gt; random = Math::random; //传统方式 double randomNumber = Math.random(); //使用Supplier\u0026lt;T\u0026gt; double randomNumber = random.get(); 新日期时间API # 新的日期时间API提供了更好的日期和时间处理，包括LocalDate、LocalTime、LocalDateTime、Instant、Duration、Period等。\nLocalDate、LocalTime、LocalDateTime：用于处理日期和时间，提供了丰富的方法进行操作。 Instant：用于表示时间戳，提供了与日期时间的转换方法。 Duration：用于表示时间间隔，提供了对时间的加减操作。 Period：用于表示日期间隔，提供了对日期的加减操作。 LocalDate date = LocalDate.now(); LocalTime time = LocalTime.now(); LocalDateTime dateTime = LocalDateTime.now(); Instant instant = Instant.now(); Duration duration = Duration.ofHours(1); Period period = Period.ofDays(1); 注意事项 # 优先使用方法引用：当Lambda表达式只是调用一个方法时，优先使用方法引用，使代码更加简洁和易读。 合理使用stream API：使用stream API可以提高代码的效率和可读性，避免了手动编写foreach循环。 避免副作用：在Stream中避免修改外部状态 谨慎使用并行流：并行流不总是更快，需要根据数据量和操作复杂度选择 在可能返回null的方法中使用Optional类来处理空指针异常。 Java17新特性 # java17是继java11之后的第二个长期支持（lts）版本，于2021年9月21日发布。\n记录类（Records）：简洁的不可变数据载体，自动生成构造器和访问器，内置equals、hashCode、toString方法，减少样板代码。 密封类：限制类的继承层次结构，提供更好的api设计控制，增强模式匹配支持，编译时类型安全保证。 模式匹配：instanceof的模式匹配，switch表达式增强，减少类型转换代码，提高代码可读性。 文本块：多行字符串字面量，保持原始格式，减少转义字符，提高代码可读性。 密封类 # 密封类是java17引入的一个新特性，用于限制类的继承层次结构。它可以用于限制哪些类可以继承自某个类，从而提高代码的安全性和可维护性。\n类型安全：编译明确只有指定的类可以继承 模式匹配：instanceof的模式匹配，switch表达式增强，减少类型转换代码，提高代码可读性。 api设计：更好地控制类的继承层次 文档化：明确报答设计意图。 sealed class Shape permits Circle, Rectangle { abstract double area(); } final class Circle extends Shape { @Override double area() { return Math.PI * radius * radius; } } final class Rectangle extends Shape { @Override double area() { return length * width; } } 记录类 # 记录类是java14引入并在java17中稳定的特性，用于创建不可变数据载体。自动生成构造器、访问器方法以及equals、hashCode、toString方法，减少样板代码。\npublic record Person(String name, int age,String email){ //紧凑构造器，用于验证和规范化 public Person{ Objects.requireNonNull(name, \u0026#34;name must not be null\u0026#34;); Objects.requireNonNull(email, \u0026#34;email must not be null\u0026#34;); if(age \u0026lt; 0 || age \u0026gt; 120){ throw new IllegalArgumentException(\u0026#34;age must be between 0 and 120\u0026#34;); } if(!email.contains(\u0026#34;@\u0026#34;)){ throw new IllegalArgumentException(\u0026#34;email must contain @\u0026#34;); } } //自定义方法 public boolean isAdult(){ return age \u0026gt;= 18; } public String getDisplayName(){ return isAdult() ? name + \u0026#34;成年\u0026#34;: name + \u0026#34;未成年\u0026#34;; } //静态工厂方法 public static Person create(String name, int age, String email){ return new Person(name, age, email); } } //嵌套记录类 record Address(String street, String city, String state, String zipCode){ public String getFullAddress(){ return street + \u0026#34;, \u0026#34; + city + \u0026#34;, \u0026#34; + state + \u0026#34; \u0026#34; + zipCode; } } //使用 class RecordDemo { public static void main(String[] args) { Person person = Person.create(\u0026#34;张三\u0026#34;, 18, \u0026#34;zhangsan@gmail.com\u0026#34;); System.out.println(person.name); System.out.println(person.age); System.out.println(person.email); System.out.println(person.getDisplayName()); System.out.println(person.isAdult()); Address address = Address.create(\u0026#34;123 Main St\u0026#34;, \u0026#34;Anytown\u0026#34;, \u0026#34;CA\u0026#34;, \u0026#34;12345\u0026#34;); System.out.println(address.getFullAddress()); } } 模式匹配 # 模式匹配主要体现在instanceof操作符和switch表达式中。\ninstanceof：用于判断对象是否属于某个类，或者实现某个接口。 switch：用于匹配多个条件，并执行对应的代码块。 public class PatternMatchingDemo { public static void processObject(Object obj){ if(obj instanceof Person person){ System.out.println(\u0026#34;处理Person对象：\u0026#34; + person); } else if(obj instanceof Address address){ System.out.println(\u0026#34;处理Address对象：\u0026#34; + address); } else if(obj instanceof String str){ System.out.println(\u0026#34;处理字符串对象：\u0026#34; + str); }else if(obj instanceof Number number){ System.out.println(\u0026#34;处理数字对象：\u0026#34; + number); }else { System.out.println(\u0026#34;未知对象类型\u0026#34;); } } } //switch表达式 public class SwitchDemo { public static void processObject(Object obj){ switch(obj){ case null -\u0026gt; System.out.println(\u0026#34;处理null对象\u0026#34;); case Integer i -\u0026gt; System.out.println(\u0026#34;处理整数对象：\u0026#34; + i); case Person person -\u0026gt; System.out.println(\u0026#34;处理Person对象：\u0026#34; + person); case Address address -\u0026gt; System.out.println(\u0026#34;处理Address对象：\u0026#34; + address); case String str -\u0026gt; System.out.println(\u0026#34;处理字符串对象：\u0026#34; + str); case Number number -\u0026gt; System.out.println(\u0026#34;处理数字对象：\u0026#34; + number); default -\u0026gt; System.out.println(\u0026#34;未知对象类型\u0026#34;); } } } 文本块 # 文本块是java15引入的一个新特性，用于表示多行字符串字面量。它可以保持原始格式，减少转义字符，提高代码可读性。三个双引号\u0026quot;\u0026ldquo;\u0026ldquo;包裹的字符串就是一个文本块。减少转义字符，降低维护成本，支持字符串格式化与插值，特别适合html\\json\\sql等多行文本。\nString json = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;age\u0026#34;: 18, \u0026#34;email\u0026#34;: \u0026#34;zhangsan@gmail.com\u0026#34; } \u0026#34;\u0026#34;\u0026#34;; System.out.println(json); 最佳实践 # 密封类：用于限制继承层次，特别适合状态机和数据模式； 记录类：优先用于不可变数据传输对象（DTO），减少样板代码； 模式匹配：在instanceof和switch表达式中使用，提高代码可读性和可维护性； 文本块：用于表示多行字符串字面量，减少转义字符，提高代码可读性； 性能考虑：新特性在提高开发效率的同时保持良好性能。 Java21新特性 # java8 2014年3月（lts）\u0026ndash;lambda表达式、stream api、方法引用 java11 2018年9月 （lts）\u0026mdash;http client、局部变量类型推断、字符串增强 java17 2021年9月（lts）\u0026mdash;密封类、模式匹配、文本块、记录类 java21是oracle在2023年9月发布的长期支持（lts）新版本\u0026mdash;虚拟线程、模式匹配增强、字符串模版、序列化集合\n虚拟线程 # 轻量级线程，可以创建数百万个，简化并发编程模型，提高应用程序吞吐量，减少内存占用。由jvm管理而不是操作系统。\n虚拟线程和平台线程\n特性 平台线程 虚拟线程 创建 需要调用Thread.ofPlatform().newThread() 无需调用任何方法 运行 需要调用start()方法启动 无需调用任何方法 销毁 需要调用join()方法等待线程结束 无需调用任何方法 创建成本 高 低 最大数量 数千个 数百万个 调度方式 操作系统调度 虚拟CPU调度 即jvm调度 阻塞行为 阻塞os线程 不阻塞载体线程 适用场景 cpu密集型任务 io密集型任务 public class VirtualThreadExample { public static void main(String[] arg)throws Exception{ basicVirtualThread(); virtualThreadExecutor(); } private static void basicVirtualThread()throws InterruptedException{ Thread vt = Thread.ofVirtual() .name(\u0026#34;basic-vt\u0026#34;) .start(() -\u0026gt; { System.out.println(\u0026#34;I am a virtual thread\u0026#34;); try{ Thread.sleep(1000); }catch(InterruptedException e){ e.printStackTrace(); } System.out.println(\u0026#34;Virtual thread completed\u0026#34;); }); vt.join(); } private static void virtualThreadExecutor()throws Exceptio{ try(var executor = Executors.newVirtualThreadPerTaskExecutor()){ List\u0026lt;\u0026gt; futures = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; 10; i++){ futures.add(executor.submit(() -\u0026gt; { System.out.println(\u0026#34;I am a virtual thread\u0026#34;); try{ Thread.sleep(1000); }catch(InterruptedException e){ e.printStackTrace(); } System.out.println(\u0026#34;Virtual thread completed\u0026#34;); })); } for(var future : futures){ future.get(); } } } } 避免在虚拟线程中使用synchronized关键字，推荐使用reentrantlock等可重入锁。 不要池化虚拟线程，它们的创建成本极低 虚拟线程适合io密集型任务，不适合cpu密集型任务 某些阻塞操作可能会固定pin虚拟线程到载体线程。 模式匹配增强 # 使得switch表达式更加强大灵活。\nprivate static void basicPatternMatching(){ Object[] testBojects = {\u0026#34;123\u0026#34;, 123, new Person(\u0026#34;张三\u0026#34;, 18), new Address(\u0026#34;中国\u0026#34;, \u0026#34;北京\u0026#34;), new StringBuilder(\u0026#34;hello\u0026#34;)}; for(Object obj : testBojects){ String result = switch(obj){ case null -\u0026gt; \u0026#34;null对象\u0026#34;; case Integer i -\u0026gt; \u0026#34;整数对象：\u0026#34; + i; case Person person -\u0026gt; \u0026#34;Person对象：\u0026#34; + person; case Address address -\u0026gt; \u0026#34;Address对象：\u0026#34; + address; case String str -\u0026gt; \u0026#34;字符串对象：\u0026#34; + str; case Number number -\u0026gt; \u0026#34;数字对象：\u0026#34; + number; default -\u0026gt; \u0026#34;未知对象类型\u0026#34;; }; } } 不学啦（不适应）\n字符串模版 # 字符串模版是预览特性，需要在编译时添加\u0026ndash;enable-preview选项开启。在生产环境中使用前要慎重。\nString name = \u0026#34;张三\u0026#34;; int age = 18; String address = \u0026#34;中国北京\u0026#34;; String feature = \u0026#34;Java21新特性\u0026#34;; String message = STR.\u0026#34;\\{name}是\\{age}岁，来自\\{address}，并使用了\\{feature}\u0026#34;; System.out.println(message); 不学啦（不适应）\n序列化集合 # java21引入了序列化集合接口，为有序集合提供了统一的api，包括首尾元素的操作方法。\nList list = new ArrayList\u0026lt;\u0026gt;(); list.addFirst(\u0026#34;first\u0026#34;); list.addLast(\u0026#34;last\u0026#34;); list.add(1,\u0026#34;中间\u0026#34;)； System.out.println(list.getFirst()); System.out.println(list.getLast()); System.out.println(list.reversed()); System.out.println(list.removeFirst()); System.out.println(list.removeLast()); 提升了开发效率，但是学习成本更高了。\n主要性能改进\n内存管理优化：改进的垃圾收集器性能；更好的内存分配策略；减少内存碎片；优化的对象布局； 启动时间优化：更快的类加载；改进的jit编译；优化的启动序列；减少冷启动时间； 运行时优化：更好的分支预测；优化的循环展开；改进的内联策略；更高效的异常处理。 安全性增强：更强的加密算法支持；改进的安全管理器；更好的证书验证；增强的随机数生成。 改进的switch表达式；改进的Math类方法；改进的StringBuilder和StringBuffer ","date":"2021年1月10日","externalUrl":null,"permalink":"/posts/java-base11/","section":"全部文章","summary":"","title":"Java 高级主题","type":"posts"},{"content":"","date":"2021年1月10日","externalUrl":null,"permalink":"/tags/java%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/","section":"Tags","summary":"","title":"Java高级主题","type":"tags"},{"content":"","date":"2021年1月10日","externalUrl":null,"permalink":"/categories/java/","section":"Categories","summary":"","title":"Java基础","type":"categories"},{"content":"Java 输入输出：IO流概述、字节流、字符流、文件操作、序列化。\nIO流概述 # Java IO流概述：IO流是Java中用于处理输入输出操作的机制。它将外部设备（如文件、网络）与Java程序连接起来，实现数据的读取和写入。流是一种抽象概念。它提供了一种统一的方式来处理不同类型的数据源和目标，如文件、内存、网络等。通过流的方式进行输入输出，数据被当作无结构的字节序列或字符序列。通过流的方式，我们可以以一致的方法读取和写入数据。\nIO流特点：\n流是一种有序的字节序列。 流可以是输入流（读取数据）或输出流（写入数据）。 流可以是字节流（处理二进制数据）或字符流（处理文本数据）。 流可以是节点流（直接操作数据源或目标）或处理流（在节点流基础上进行封装，提供额外的功能）。 流的操作是顺序的，一次只能处理一个字节或字符。 流的操作可以是阻塞的，即等待数据准备就绪或空间可用。 流的操作可以抛出IOException异常，需要进行异常处理。 流的操作完成后，需要关闭流以释放系统资源。 统一性：所有IO操作都通过流的方式进行 抽象性：提供了统一的接口，屏蔽了底层实现细节 可扩展性：通过装饰器模式可以灵活组合功能 高效性：提供了缓冲机制提高IO性能。 IO流分类 # 按照数据单位分类 字节流：以字节（8位）为单位进行读写操作，适用于处理二进制数据。 字符流：以字符（16位）为单位进行读写操作，适用于处理文本数据。 按照流的方向分类 输入流：从外部设备读取数据到Java程序。InputStream\\Reader 输出流：从Java程序写入数据到外部设备。OutputStream\\Writer 按照流的功能（角色）分类 节点流：直接操作数据源或目标，如文件流、数组流等。FileInputStream\\FileReader\\FileOutputStream\\FileWriter 处理流：在节点流基础上进行封装，提供额外的功能，如缓冲流、转换流等。BufferedInputStream\\BufferedOutputStream\\BufferedReader\\BufferedWriter 按照流的使用场景分类 字节流：适用于处理二进制数据，如图片、视频、音频等。 字符流：适用于处理文本数据，如普通文本文件、配置文件等。 流的继承体系 # 基类 类型 常用实现类 主要用途 InputStream 字节输入流 FileInputStream、BufferedInputStream 从文件或其他数据源读取字节数据 OutputStream 字节输出流 FileOutputStream、BufferedOutputStream 将字节数据写入文件或其他目标 Reader 字符输入流 FileReader、BufferedReader 从文件或其他数据源读取字符数据 Writer 字符输出流 FileWriter、BufferedWriter 将字符数据写入文件或其他目标 装饰器模式在IO流中的应用 # 装饰器模式是一种结构型设计模式，它允许在不改变原有对象结构的情况下，动态地给对象添加新的功能。在IO流中，装饰器模式被广泛应用于添加额外的功能，如缓冲、转换、加密等。通过装饰器模式，我们可以在不修改原有流的情况下，灵活地组合不同的功能。\n//基础流（节点流） FileInputStream fileStream = new FileInputStream(\u0026#34;file.txt\u0026#34;); // (第一层装饰）添加缓冲功能 BufferedInputStream bufferedStream = new BufferedInputStream(fileStream); //（第二层装饰）添加数据类型读取功能 DataInputStream dataStream = new DataInputStream(bufferedStream); //现在可以高效地读取各种数据类型 int number = dataStream.readInt(); double doubleValue = dataStream.readDouble(); String text = dataStream.readUTF(); 装饰器模式的优势\n可以动态地给对象添加功能 通过组合而非继承实现功能扩展 符合开闭原则，易于扩展 避免了类爆炸问题 选择合适的流类型 # 处理文本数据选择字符流 处理二进制数据选择字节流 频繁读写使用缓冲流 需要类型转换使用数据流 字节流 # 字节流特点\n处理二进制数据：适合处理图片、音频、视频等二进制文件 以字节为单位：每次读写一个或多个字节 通用性强：可以处理任何类型的文件 效率较高：直接操作字节，没有编码转换开销 字节流的主要实现类 # FileInputStream：从文件读取字节（针对java程序是输入流） FileOutputStream：向文件写入字节（针对java程序是输出流） BufferedInputStream：添加缓冲功能，提高读取效率 BufferedOutputStream：添加缓冲功能，提高写入效率 DataInputStream：添加数据类型读取功能 DataOutputStream：添加数据类型写入功能 ByteArrayInputStream:字节数组输入流，从字节数组读取数据（不涉及到磁盘io文件操作，在内存中操作，适合临时数据处理和数据转换） ByteArrayOutputStream:字节数组输出流，向字节数组写入数据（不涉及到磁盘io文件操作，在内存中操作，适合临时数据处理和数据转换） 字节流类型比较 # 流类型 适用场景 性能特点 使用建议 FileInputStream 从文件读取字节 效率高，直接操作字节 适用于处理二进制文件(小文件512字节\u0026ndash;4kb) FileOutputStream 向文件写入字节 效率高，直接操作字节 适用于处理二进制文件 BufferedInputStream 添加缓冲功能，提高读取效率 效率高，减少磁盘io次数 适用于频繁读取操作（大文件8kb-64kb） BufferedOutputStream 添加缓冲功能，提高写入效率 效率高，减少磁盘io次数 适用于频繁写入操作 DataInputStream 添加数据类型读取功能 方便读取各种数据类型 适用于需要读取不同数据类型的场景 DataOutputStream 添加数据类型写入功能 方便写入各种数据类型 适用于需要写入不同数据类型的场景 ByteArrayInputStream 从字节数组读取数据 效率高，在内存中操作 适用于临时数据处理和数据转换 ByteArrayOutputStream 向字节数组写入数据 效率高，在内存中操作 适用于临时数据处理和数据转换 字符流 # 字符流特点\n处理文本数据：适合处理普通文本文件、配置文件等 以字符为单位：每次读写一个或多个字符 编码转换：自动处理字符编码转换，无需手动处理 效率较低：相对于字节流，每次读写操作需要进行编码转换 字符流的主要实现类 # FileReader：从文件读取字符（针对java程序是输入流） FileWriter：向文件写入字符（针对java程序是输出流） BufferedReader：添加缓冲功能，提高读取效率 BufferedWriter：添加缓冲功能，提高写入效率 InputStreamReader：将字节流转换为字符流（针对java程序是输入流） OutputStreamWriter：将字符流转换为字节流（针对java程序是输出流） PrintWriter：方便打印输出，自动处理换行符,自动刷新功能。 字符流最佳实践 # 选择合适的字符编码：根据实际情况选择合适的字符编码，避免编码转换问题。 处理异常：在字符流操作中，需要注意处理异常，如文件不存在、编码转换错误等。 关闭流：在使用完字符流后，需要及时关闭流，释放资源。 缓冲区大小：根据实际情况调整缓冲区大小，平衡读写效率和内存占用。 考虑使用try-with-resources语句自动关闭流，避免资源泄漏。 重要数据及时刷新缓冲区 什么时候使用字符流，什么时候使用字节流 # 处理文本数据选择字符流（字符流能自动处理字符编码，更适合文本操作） 处理二进制数据选择字节流（字节流直接操作字节，没有编码转换开销，更适合处理二进制文件，图片、视频、音频等） 如何处理中文乱码问题 # 使用InputStreamReader和OutputStreamWriter处理中文乱码问题\n读取文件时，使用InputStreamReader指定字符编码，如new InputStreamReader(fileStream, \u0026ldquo;UTF-8\u0026rdquo;) 写入文件时，使用OutputStreamWriter指定字符编码，如new OutputStreamWriter(fileStream, \u0026ldquo;UTF-8\u0026rdquo;) BufferReader的缓冲区大小是多少 # 默认缓冲区大小是8192字节（8kb），合理的缓冲区大小能显著提高io性能。\nFile文件操作 # 创建file文件 # file对象可以表示文件或目录，创建file对象并不会在文件系统中创建实际的文件或目录。 需要通过file对象的方法来创建实际的文件或目录，如createNewFile()、mkdir()、mkdirs()等。\n// 创建文件对象 File file = new File(\u0026#34;test.txt\u0026#34;); try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } //使用路径创建 // 使用路径创建文件对象 File file2 = new File(\u0026#34;testDir/test.txt\u0026#34;); try { file2.createNewFile(); } catch (IOException e) { e.printStackTrace(); } //创建目录 File dir = new File(\u0026#34;testDir\u0026#34;); dir.mkdir(); //创建多级目录 File dirs = new File(\u0026#34;testDir1/testDir2\u0026#34;); dirs.mkdirs(); 文件基本操作 # File file = new File(\u0026#34;test.txt\u0026#34;); //创建一个新的空文件 file.createNewFile(); //判断文件是否存在 boolean exists = file.exists(); //判断是否是文件 boolean isFile = file.isFile(); //判断是否是目录 boolean isDir = file.isDirectory(); //判断是否可读 boolean isReadable = file.canRead(); //判断是否可写 boolean isWritable = file.canWrite(); //遍历目录中的所有文件 File[] files = dir.listFiles(); //遍历目录中的所有文件和子目录 for (File f : files) { if (f.isFile()) { System.out.println(\u0026#34;文件：\u0026#34; + f.getName()); } else if (f.isDirectory()) { System.out.println(\u0026#34;目录：\u0026#34; + f.getName()); } } //获取文件名称 String name = file.getName(); //获取文件路径 String path = file.getPath(); //获取文件绝对路径 String absPath = file.getAbsolutePath(); //获取文件父目录 File parentDir = file.getParentFile(); //文件大小 long size = file.length(); //文件最后修改时间 long lastModified = file.lastModified(); //删除文件 boolean deleted = file.delete(); File.separator\n文件分隔符 在不同操作系统中，文件路径的分隔符是不同的，如Windows使用反斜杠\\，而Unix/Linux使用正斜杠/。 为了跨平台兼容性，建议使用File.separator来表示文件路径分隔符。 //例如： String filePath = \u0026#34;testDir\u0026#34; + File.separator + \u0026#34;test.txt\u0026#34;; //在Windows中，filePath为\u0026#34;testDir\\test.txt\u0026#34; //在Unix/Linux中，filePath为\u0026#34;testDir/test.txt\u0026#34; Paths.get()\n用于创建Path对象，Path对象表示文件路径。 可以接受多个字符串参数，每个参数表示路径的一部分，用File.separator分隔。 可以跨平台兼容，自动处理不同操作系统的文件路径分隔符。 //例如： Path path = Paths.get(\u0026#34;testDir\u0026#34;, \u0026#34;test.txt\u0026#34;); //在Windows中，path为\u0026#34;testDir\\test.txt\u0026#34; //在Unix/Linux中，path为\u0026#34;testDir/test.txt\u0026#34; ⚠️注意\n对于大量文件操作，建议使用NIO.2(java.nio.file包)，它提供了更好的性能和更丰富的功能。对于简单的文件操作，传统的file类也提供了丰富的方法。 文件操作涉及到系统资源，务必注意异常处理和资源释放。在多线程环境下进行文件操作时，要考虑线程安全问题。删除文件或目录前，确保没有其他程序正在使用。 File类 vs NIO # 特性 File类 NIO.2（java.nio.file包） 性能 一般 较高 功能 基本 丰富 跨平台 是 是 线程安全 否 是 异常处理 简单返回boolean 复杂抛出异常 资源释放 手动 自动 符号链接支持 不支持 支持 文件属性 基本 详细 符号链接 # 符号链接（Symbolic Link）是一种特殊的文件，它指向另一个文件或目录。符号链接可以跨文件系统，而硬链接只能在同一文件系统中。 NIO.2提供了对符号链接的支持，可以使用Files.createSymbolicLink()方法创建符号链接。\n//创建符号链接 Path link = Files.createSymbolicLink(Paths.get(\u0026#34;link.txt\u0026#34;), Paths.get(\u0026#34;target.txt\u0026#34;)); 文件属性 # NIO.2提供了丰富的文件属性操作方法，如获取文件大小、最后修改时间、权限等。可以使用Files.readAttributes()方法读取文件属性。\n//读取文件属性 BasicFileAttributes attrs = Files.readAttributes(Paths.get(\u0026#34;test.txt\u0026#34;), BasicFileAttributes.class); //获取文件大小 long size = attrs.size(); //获取最后修改时间 Instant lastModified = attrs.lastModifiedTime(); //获取权限 PosixFilePermissions permissions = Files.getPosixFilePermissions(Paths.get(\u0026#34;test.txt\u0026#34;)); File.delete()返回false怎么办 # 检查文件是否存在 检查文件是否被其他程序占用 检查文件是否为只读 检查文件是否为系统文件 检查文件是否为隐藏文件 检查文件是否为目录，确保目录为空 检查文件是否为符号链接 检查文件是否为挂载点 检查文件是否为设备文件 检查文件是否为管道文件 检查文件是否为套接字文件 检查文件是否为字符设备文件 检查文件是否为块设备文件 检查文件是否为目录符号链接 检查文件是否为文件符号链接 检查文件是否为挂载点符号链接 检查文件是否为设备符号链接 检查文件是否为管道符号链接 检查文件是否为套接字符号链接 检查文件是否为字符设备符号链接 检查文件是否为块设备符号链接 如何处理文件编码问题 # 使用InputStreamReader和OutputStreamWriter处理文件编码问题。或者使用NIO的Charset类处理编码问题。\n大文件操作如何优化 # 使用缓冲流、NIO的通道（Channel）和缓冲区（Buffer）进行大文件操作，或者分块处理大文件。\n如何安全删除目录 # 先递归删除目录中的所有文件和子目录，最后删除目录本身。\n练习建议 # 文件搜索工具：实现一个文件搜索工具，支持按照名称、大小、修改时间搜索 文件备份工具：实现一个文件备份工具，支持增量备份和全量备份。 文件管理器：实现一个简单的文件管理器，支持文件的复制、移动、删除、重命名等操作。 日志分析工具：实现一个简单的日志分析工具，支持按照时间、级别、内容搜索日志，统计日志文件的各种信息。 序列化 # Java序列化是将对象的状态转换为字节流的过程，以便可以将对象保存到文件、数据库或通过网络传输。反序列化是相反的过程，将字节流转换回对象，恢复其状态。用于分布式系统、缓存和持久化存储等场景。\n持久化存储：将对象转换为字节流，保存到文件或数据库中，以便后续恢复对象状态。 缓存机制：将对象转换为字节流，存储在缓存中，以提高访问速度。 网络传输：将对象转换为字节流，通过网络传输到远程节点，实现分布式系统中的通信。 深度复制：创建对象的完整副本，包括所有嵌套对象。 Serializable 接口 # Serializable 接口是Java中用于序列化的标记接口。实现了Serializable接口的类可以被序列化，即转换为字节流进行存储或传输。反序列化时，字节流会被转换回对象。\nimport java.io.Serializable; public class MyClass implements Serializable { private static final long serialVersionUID = 1L; //类的成员变量 private int id; private String name; //构造方法 public MyClass(int id, String name) { this.id = id; this.name = name; } //其他方法 //... } 注意：serialVersionUID 是用于序列化和反序列化的版本控制机制。如果类的 serialVersionUID 与序列化时的 serialVersionUID 不匹配，会抛出 InvalidClassException 异常。\ntransient 关键字 # transient 关键字用于标记类的成员变量，在序列化时会被忽略。这在某些场景下非常有用，例如密码、敏感信息等。\nimport java.io.Serializable; public class MyClass implements Serializable { private static final long serialVersionUID = 1L; //类的成员变量 private int id; private transient String password; //构造方法 public MyClass(int id, String password) { this.id = id; this.password = password; } //其他方法 //... } 注意：transient 关键字标记的成员变量在反序列化时会被初始化为默认值，例如 int 类型为 0，引用类型为 null。\n常见问题 # 忘记实现 Serializable 接口：如果类没有实现 Serializable 接口，尝试序列化时会抛出 NotSerializableException 异常。 忘记添加 serialVersionUID：如果类没有添加 serialVersionUID 字段，尝试序列化时会抛出 InvalidClassException 异常。 忘记处理 IOException：在序列化和反序列化过程中，可能会抛出 IOException 异常，需要进行适当的处理。 忘记处理 ClassNotFoundException：在反序列化过程中，可能会抛出 ClassNotFoundException 异常，需要进行适当的处理。 序列化大对象或者频繁序列化操作：使用BufferedStream,避免序列化不必要的字段。 安全问题：反序列化不可信数据可能导致安全漏洞，例如反序列化攻击（如利用序列化的对象执行恶意代码），使用白名单机制。 当父类没有实现 Serializable 接口时，子类可以实现 Serializable 接口吗？ 可以。子类可以实现 Serializable 接口，在序列化时，父类的状态也会被序列化。但是父类必须有一个无参的构造器，在反序列化时，父类的无参构造器会被调用来初始化父类部分，如果父类没有无参构造器，会在反序列化时抛出 InvalidClassException 异常。 要自定义序列化过程，可以在类中实现 writeObject 和 readObject 方法。这两个方法分别在序列化和反序列化时被调用，用于自定义序列化和反序列化过程。\n序列化代替方案 # java原生的序列化机制 JSON：将对象转换为 JSON 字符串，进行存储或传输。反序列化时，将 JSON 字符串转换回对象。web api XML：将对象转换为 XML 字符串，进行存储或传输。反序列化时，将 XML 字符串转换回对象。 协议缓冲区（Protocol Buffers）：Google 开发的一种二进制序列化格式，效率高，支持跨平台。 Apache Avro : 是一种基于二进制的序列化格式，由 Apache 软件基金会开发。它支持动态类型，提供高效的序列化和反序列化操作。适合大数据场景。 ","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base10/","section":"全部文章","summary":"","title":"Java 输入输出","type":"posts"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","section":"Tags","summary":"","title":"Java输入输出","type":"tags"},{"content":"Java 集合框架：集合框架概述、List、ArrayList、LinkedList、Vector\u0026amp;Stack、Set、Map、Queue、Iterator迭代器。\n集合框架概述 # 集合框架（Java Collections Framework）JCF是java平台用于存储和操作对象集合的统一架构。\n优势\n统一的架构：提供了一致的api来操作不同类型的集合 高性能：针对不同场景优化的数据结构实现 互操作性：不同集合类型之间可以互相转换 可扩展性：可以轻松创建自定义集合实现 Java 集合框架继承体系图 # Iterable ├── Collection │ ├── List │ │ ├── ArrayList │ │ ├── LinkedList │ │ └── Vector \u0026amp; Stack │ ├── Set │ │ ├── HashSet │ │ ├── LinkedHashSet │ │ └── TreeSet │ └── Queue │ ├── ArrayDeque │ ├── LinkedList │ └── PriorityQueue Map ├── HashMap ├── LinkedHashMap ├── TreeMap └── HashTable ⚠️ Map接口并不继承Collection接口，而是独立存在，表示键值对的映射关系，而Collection接口表示单个对象的集合。\nList接口：有序集合，允许重复元素，保持插入顺序，提供基于索引的访问和操作方法，提供迭代器遍历元素。 Set接口：无序集合，不允许重复元素，不保持插入顺序，最多包含一个null元素，基于equals()方法判断重复，支持集合运算，无索引访问，提供基于元素内容的访问和操作方法，提供迭代器遍历元素。 Queue接口：有序集合，允许重复元素，保持插入顺序，提供基于索引的访问和操作方法，提供迭代器遍历元素。 Map接口：键值对映射集合，键不能重复，值可以重复，支持null键和值，不继承Collection接口，独立存在，提供基于键的访问和操作方法，提供迭代器遍历键值对，提供三种视图：键视图、值视图、键值对视图。 SortedSet接口：有序集合，不允许重复元素，不保持插入顺序，最多包含一个null元素，基于compareTo()方法判断重复，支持集合运算，无索引访问，提供基于元素内容的访问和操作方法，提供迭代器遍历元素，支持范围查询，提供首尾元素访问，子集视图，Compatator支持。 主要实现类比较 # List实现类比较\n实现类 底层结构 访问性能 插入/删除性能 线程安全 适用场景 ArrayList 动态数组 快o(1) 慢o(n) 否 随机访问频繁，插入删除操作少 LinkedList 双向链表 慢o(n) 快o(1) 否 频繁插入删除操作，不随机访问 Vector \u0026amp; Stack 动态数组 快o(1) 慢o(n) 是 线程安全，随机访问频繁，插入删除操作少 Set实现类比较\n实现类 底层结构 访问性能 插入/删除性能 线程安全 适用场景 null支持 排序 HashSet 哈希表 快o(1) 快o(1) 否 不要求有序，不允许重复元素，快速查找 支持 无序 LinkedHashSet 哈希表 + 链表 快o(1) 快o(1) 否 不要求有序，不允许重复元素，需要保持插入顺序 支持 插入顺序 TreeSet 红黑树 快o(logn) 快o(logn) 否 要求有序，不允许重复元素 不支持 自然顺序 Map实现类比较\n实现类 底层结构 访问性能 插入/删除性能 线程安全 适用场景 null支持 排序 HashMap 哈希表 快o(1) 快o(1) 否 不要求有序，不允许重复键，快速查找 键值都支持 无序 LinkedHashMap 哈希表 + 链表 快o(1) 快o(1) 否 不要求有序，不允许重复键，需要保持插入顺序 键值都支持 插入/访问顺序 TreeMap 红黑树 快o(logn) 快o(logn) 否 要求有序，不允许重复键 值支持，键不支持 键自然顺序 HashTable 哈希表 快o(1) 快o(1) 是 不要求有序，不允许重复键，快速查找 键值都不支持 无序 集合选择建议 # 需要索引访问：List 不允许重复：Set 键值对映射：Map 有序集合：SortedSet FIFO操作（队列）：Queue 频繁随机访问：ArrayList 频繁插入删除操作：LinkedList 线程安全：Vector \u0026amp; Stack \u0026amp; HashTable 需要排序：TreeSet \u0026amp; TreeMap 性能优化建议 # 初始容量：为ArrayList和HashMap指定初始容量，避免频繁扩容. 负载因子：为HashMap和LinkedHashMap指定合适的负载因子，平衡空间利用率和查找性能 迭代器：使用迭代器遍历集合元素，而不是传统的for循环，因为迭代器提供了安全的删除操作，避免ConcurrentModificationException异常； 批量操作：使用批量操作方法（如addAll、removeAll）而不是单个元素操作，提高效率 并发考虑：多线程环境下选择合适的并发集合。 避免自动装箱拆箱：使用基本数据类型的包装类时，避免自动装箱拆箱操作，影响性能 选择合适的遍历方式：使用foreach循环或迭代器遍历集合，避免使用传统的for循环，因为foreach循环更简洁、更安全 及时释放资源：在使用完集合后，及时调用clear方法清空集合元素，避免占用过多内存 注意内存泄漏：避免集合元素持有对外部对象的引用，导致内存泄漏问题。 List 接口 # 有序性：元素按照插入顺序存储，每个元素都是一个确定的位置索引。 可重复：允许存储重复的元素，同一个对象可以在list中多次出现。 索引访问：支持通过索引直接访问、修改和删除指定位置的元素。 动态大小：List的大小可以动态增长和缩减，不需要预先指定容量。 ArrayList 实现类 # 底层结构：基于Object[]数组，支持动态扩容。动态数组，连续的内存空间存储元素。 访问性能：快o(1)，直接通过索引随机访问元素。 插入/删除性能：慢o(n)，因为需要移动后续元素。在末尾操作效率高，中间操作需要移动元素。 线程安全：非线程安全，多线程环境需要外部同步，不支持并发操作。 内存效率：连续内存存储，空间利用率高。 适用场景：随机访问频繁，插入删除操作少。 扩容机制 # //ArrayList 扩容机制 ArrayList list = new ArrayList\u0026lt;\u0026gt;(); //当元素数量超过当前容量时，会触发扩容 //新容量 = 旧容量 + 旧容量 \u0026gt;\u0026gt; 1 //即增长50% //建议：如果知道大概大小，可以指定初始容量 //指定初始容量为10 ArrayList list = new ArrayList\u0026lt;\u0026gt;(1000); LinkedList 实现类 # 底层结构：基于双向链表，每个元素包含数据和前后指针。 访问性能：慢o(n)，因为需要遍历链表才能访问到指定位置的元素。 插入/删除性能：快o(1)，因为只需要修改前一个元素和后一个元素的引用即可。 线程安全：非线程安全，多线程环境需要外部同步，不支持并发操作。 内存效率：非连续内存存储，每个元素占用额外的空间存储引用。 双端队列：实现了Deque接口，可以作为栈和队列使用。 适用场景：频繁插入删除操作，不随机访问。 最佳实践 # ❗️选择合适的类\n默认选择： 随机访问频繁：ArrayList 频繁插入删除操作：LinkedList 线程安全：collection.synchronizedList(new ArrayList\u0026lt;\u0026gt;()) 或者copyonwriteArrayList. 性能优化：合理设置ArrayList的初始容量，避免频繁扩容。 ⚠️注意事项\n遍历时修改：避免在增强for循环中修改list，使用Iterator的remove方法安全删除元素。 索引越界：访问元素前检查索引范围； null值处理：ArrayList和LinkedList都支持存储null值，需要注意空指针异常。 equals方法：自定义对象需要正确实现equals和hashCode方法，否则可能导致数据丢失。 ArrayList 实现类 # 动态扩容：当元素数量超过当前容量时，会触发扩容。原来的1.5倍，新容量 = 旧容量 + 旧容量 \u0026raquo; 1 有序集合：保持插入顺序 允许重复：允许存储重复的元素，同一个对象可以在list中多次出现，也可以存储null值； 非线程安全：多线程环境需要外部同步，不支持并发操作。 实际应用场景 # 购物车功能（存储用户选择的商品，支持添加、删除、修改数量等操作） 学生成绩管理（支持查询、排序、统计等功能） 数据过滤转换（对数据进行过滤、映射、排序等操作，配合Stream API使用） 分页功能(实现数据分页显示，通过subList方法获取指定范围的元素，即指定页面的数据) 注意事项 # ArrayList不是线程安全的，在多线程环境下，如果多个线程同时修改ArrayList，可能会导致数据不一致。解决方案：使用Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;())或者CopyOnWriteArrayList或者使用显式同步（synchronized关键字） 内存管理：删除元素时不会自动缩容，可能造成内存浪费，如果需要释放内存，可以调用trimToSize方法，及时释放不再使用的ArrayList对象，避免内存泄漏问题。 不要在迭代时修改ArrayList的结构（删除或添加元素）,否则会导致ConcurrentModificationException异常。应该使用迭代器的remove()方法和removeIf(); 遍历元素时，建议使用foreach循环或迭代器，而不是传统的for循环，因为foreach循环更简洁、更安全。 常用方法 # add(E e): 添加元素到链表末尾。 add(int index, E e): 在指定位置插入元素。 get(int index): 获取指定位置的元素。 remove(int index): 删除指定位置的元素。 size(): 返回链表的大小（元素数量）。 isEmpty(): 判断链表是否为空。 clear(): 清空链表所有元素。 LinkedList 实现类 # 链表结构：每个元素包含数据和前后指针，每个元素之间通过指针连接起来。 访问性能：慢o(n)，因为需要遍历链表才能访问到指定位置的元素。 插入/删除性能：快o(1)，因为只需要修改前/后一个元素的引用即可。 线程安全：非线程安全，多线程环境需要外部同步，不支持并发操作。 内存效率：非连续内存存储，每个元素占用额外的空间存储引用。 双端队列：实现了Deque接口，可以作为栈和队列使用。 适用场景：频繁插入删除操作，不随机访问。 实际应用场景： 缓存：LRU缓存，使用LinkedList实现，将最近使用的元素移到链表头部，将最久未使用的元素移到链表尾部。新访问的元素移到头部；超出容量时删除尾部元素；O(1)时间复杂度的操作； 撤销功能：文本编辑器、图形软件等需要撤销功能时，可以使用linkedList存储操作历史。新操作添加到头部；撤销时从头部删除；支持多级撤销。 任务队列：在多线程环境下，linkedlist可以作为任务队列，支持高效的任务添加和获取。生产者在尾部添加任务，消费者从头部获取任务，O(1)时间复杂度的操作，支持优先级任务插入。 接口实现：\npublic class LinkedList extends AbstractSequentialList implements List, Deque, Cloneable, java.io.Serializable { } 常用方法 # add(E e): 添加元素到链表末尾。 add(int index, E e): 在指定位置插入元素。 addFirst(E e): 在链表开头添加元素。 addLast(E e): 在链表末尾添加元素。 list.offer(E e):入队（末尾添加）。 list.offerFirst(E e):入队（开头添加）。 list.offerLast(E e):入队（末尾添加）。 get(int index): 获取指定位置的元素。需要从头或者尾部开始遍历，时间复杂度为O(n) remove(): 删除链表头部的元素。 remove(int index): 删除指定位置的元素。 removeFirst(): 删除链表头部的元素。 removeLast(): 删除链表尾部的元素。 offer(E e):入队（末尾添加）。 push(): 入栈（添加到头部）。 poll(): 出队（删除并返回头部元素）。 pollFirst(): 出队（删除并返回头部元素）。 pollLast(): 出队（删除并返回尾部元素）。 peek(): 获取但不删除链表头部的元素。 peekFirst(): 获取但不删除链表头部的元素。 peekLast(): 获取但不删除链表尾部的元素。 size(): 获取链表的大小（元素数量）。 isEmpty(): 判断链表是否为空。 clear(): 清空链表所有元素。 toArray(): 将链表转换为数组。 toArray(T[] a): 将链表转换为指定类型的数组。 clone(): 复制链表。 equals(Object o): 比较两个链表是否相等。 hashCode(): 返回链表的哈希值。 toString(): 返回链表的字符串表示。 Vector 实现类 # 线程安全：Vector是线程安全的，多个线程可以同时访问Vector对象，不会出现数据不一致的问题。 性能：由于线程安全的机制，Vector的性能相对较低，不建议在单线程环境下使用。 内存效率：Vector是连续内存存储，每个元素占用额外的空间存储引用。 适用场景：多线程环境下需要对共享数据进行安全访问的场景。 实际应用场景： 数据库连接池：在多线程环境下，多个线程需要同时访问数据库连接池，Vector可以作为线程安全的连接池实现。 配置文件读取：在多线程环境下，多个线程需要同时读取配置文件，Vector可以作为线程安全的配置文件读取器实现。 共享数据：在多线程环境下，多个线程需要共享数据，Vector可以作为线程安全的共享数据容器实现。 计数器：在多线程环境下，多个线程需要对共享计数器进行操作，Vector可以作为线程安全的计数器实现。 线程池：在多线程环境下，多个线程需要同时执行任务，Vector可以作为线程安全的线程池实现。 消息队列：在多线程环境下，多个线程需要同时发送和接收消息，Vector可以作为线程安全的消息队列实现。 事件通知：在多线程环境下，多个线程需要同时监听和处理事件，Vector可以作为线程安全的事件通知容器实现。 缓存：在多线程环境下，多个线程需要同时访问缓存数据，Vector可以作为线程安全的缓存实现。 Vector类继承自AbstractList类，实现了List接口，因此Vector类也继承了AbstractList类的方法。Vector类提供了线程安全的操作，因此Vector类在多线程环境下可以安全地使用。Vector类提供了一些常用的方法，如add()、get()、remove()、size()、isEmpty()、clear()、toArray()、clone()、equals()、hashCode()、toString()等。\n接口实现：\npublic class Vector\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable { } ArrayDeque 实现类 # 双端队列：实现了Deque接口，可以作为栈和队列使用。 适用场景：频繁插入删除操作，不随机访问。 实际应用场景： 缓存：LRU缓存，使用LinkedList实现，将最近使用的元素移到链表头部，将最久未使用的元素移到链表尾部。新访问的元素移到头部；超出容量时删除尾部元素；O(1)时间复杂度的操作； 撤销功能：文本编辑器、图形软件等需要撤销功能时，可以使用linkedList存储操作历史。新操作添加到头部；撤销时从头部删除；支持多级撤销。 任务队列：在多线程环境下，linkedlist可以作为任务队列，支持高效的任务添加和获取。生产者在尾部添加任务，消费者从头部获取任务，O(1)时间复杂度的操作，支持优先级任务插入。 接口实现：\npublic class LinkedList extends AbstractSequentialList implements List, Deque, Cloneable, java.io.Serializable { } 链表类LinkedList实现了Deque接口，因此LinkedList类也可以作为栈和队列使用。LinkedList类提供了一些常用的方法，如add()、addFirst()、addLast()、getFirst()、getLast()、remove()、removeFirst()、removeLast()、size()、isEmpty()、clear()、toArray()、clone()、equals()、hashCode()、toString()等。\nSet 接口 # 主要特点\n不允许重复元素：set中不能包含两个相等的元素 最多包含一个null值：如果set允许null值，最多只能一个null值； 无索引访问：set没有索引，不能通过下标访问元素； 集合运算：支持并集、交集、差集等数学集合运算。 set实现类对比\n实现类 底层实现 排序特性 性能 允许null值 线程安全 索引访问 适合场景 HashSet 哈希表 无序 快 允许 不安全 不允许 适用于不重复的元素 TreeSet 红黑树 自然排序 慢 不允许 不安全 不允许 适用于有序的元素 LinkedHashSet 哈希表 + 链表 插入顺序 中等 允许 不安全 不允许 适用于有序的元素 HashSet 实现类 # 高性能特点\n基于哈希表实现 平均时间复杂度为O(1)，查找、插入、删除元素都是O(1) 空间效率高，每个元素占用额外的空间存储引用。 无序存储\n不保证元素的迭代顺序 元素位置由哈希值决定 适合不关心顺序的场景 大多数情况下的首选 LinkedHashSet 实现类 # 继承自HashSet类，添加了LinkedHashMap的实现，因此LinkedHashSet类也继承了LinkedHashMap类。\nLinkedHashSet类提供了有序存储的集合，迭代时返回的元素顺序与添加的顺序一致。 可以预测的迭代顺序，即添加的顺序。 适合缓存、历史记录 性能略低于HashSet类，因为LinkedHashMap类比HashSet类多一个链表结构，存储元素的顺序。 应用场景\n浏览历史记录 购物车商品去重 标签系统 需要保持顺序的集合 数据库查询结果去重 TreeSet 实现类 # 基于红黑树（自平衡二叉搜索树）实现，提供了自动排序功能和丰富的导航功能。\n自动排序\n元素自然排序 支持自然排序 支持自定义比较器 O(logN)时间复杂度 导航功能\nfirst()：返回第一个元素 last()：返回最后一个元素 lower(E e)：返回小于e的最大元素 higher(E e)：返回大于e的最小元素 floor(E e)：返回小于等于e的最大元素 subSet(E fromElement, E toElement)：返回指定范围内的元素 headSet(E toElement)：返回小于指定元素的元素 tailSet(E fromElement)：返回大于等于指定元素的元素 smallest()： 获取最小元素 性能对比 # 添加操作：HashSet \u0026gt; LinkedHashSet \u0026gt; TreeSet 删除操作：HashSet \u0026gt; LinkedHashSet \u0026gt; TreeSet 查找操作：HashSet ~ LinkedHashSet \u0026gt; TreeSet 内存使用：HashSet \u0026lt; LinkedHashSet \u0026lt; TreeSet 排序需求：只有TreeSet类支持排序，其他类都是无序的。 实际应用场景 # 用户权限管理-hashset 浏览历史记录-linkedhashset（保持插入顺序） 排行榜系统-treeset（需要排序） set实现类都不是线程安全的，如果需要线程安全，可以使用Collections.synchronizedSet()方法返回一个同步的set对象。或者使用ConcurrentHashMap类作为基础，创建一个线程安全的set对象。考虑使用并发集合类。 重写equals()和hashCode()方法，以实现自定义的比较逻辑。- 创建一个自定义的比较器，并使用TreeSet类实现排序。保证数据的一致性和正确性。 hashset元素顺序不确定，不要依赖迭代顺序； treeset不允许null值，因为它需要使用元素的compareTo()方法进行排序，而null值没有定义的排序顺序。可能会抛出NullPointerException异常。 自定义对象必须正确实现equals()和hashCode()方法，否则可能会导致数据不一致。 修改已经添加到set中的对象，可能会导致数据不一致。 在多线程环境下需要考虑线程安全问题。 Map 接口 # 主要特点\n键（key）必须唯一，值（value）可以重复 一个键最多只能映射到一个值 键不能为null，值可以为null 常用实现类：HashMap、LinkedHashMap、TreeMap、HashTable、ConcurrentHashMap、WeakHashMap、IdentityHashMap 提供基于键的快速查询功能 不继承Collection接口，继承AbstractMap类 核心方法\n方法 描述 put(K key, V value) 向map中添加一个键值对 get(Object key) 返回指定键所映射的值 remove(Object key) 删除指定键所映射的键值对 containsKey(Object key) 判断map是否包含指定键 containsValue(Object value) 判断map是否包含指定值 size() 返回map中键值对的数量 isEmpty() 判断map是否为空 clear() 清空map中的所有键值对 keySet() 返回map中所有键的set集合 values() 返回map中所有值的collection集合 entrySet() 返回map中所有键值对的set 集合 putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m) 将m中的所有键值对添加到当前map中 HashMap 实现类 # HashMap类基于哈希表实现，使用哈希函数将键映射到数组中的索引位置，并使用链表解决冲突。 线程不安全，不保证迭代顺序。 允许null键和null值。 初始容量为16，加载因子为0.75。 当元素数量超过容量*加载因子时，会触发扩容操作，将容量翻倍。 扩容时需要重新计算哈希值，可能会导致性能下降。 不支持同步，多线程环境下需要使用ConcurrentHashMap类。 LinkedHashMap 实现类 # LinkedHashMap类基于哈希表和链表实现，继承自HashMap类。 线程不安全，保证迭代顺序，维护插入或访问顺序。 允许null键和null值。 初始容量为16，加载因子为0.75。 当元素数量超过容量*加载因子时，会触发扩容操作，将容量翻倍。 扩容时需要重新计算哈希值，可能会导致性能下降。 不支持同步，多线程环境下需要使用ConcurrentHashMap类。 迭代顺序与插入顺序一致，适合需要保持顺序的场景。 //创建一个按访问顺序排序的LinkedHashMap对象 LinkedHashMap\u0026lt;String, String\u0026gt; linkedHashMap = new LinkedHashMap\u0026lt;\u0026gt;(16, 0.75f, true); linkedHashMap.put(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); TreeMap 实现类 # TreeMap类基于红黑树实现，继承自AbstractMap类。 线程不安全，不保证迭代顺序。 不允许null键，允许null值。 初始容量为16，加载因子为0.75。 当元素数量超过容量*加载因子时，会触发扩容操作，将容量翻倍。 扩容时需要重新计算哈希值，可能会导致性能下降。 不支持同步，多线程环境下需要使用ConcurrentHashMap类。 迭代顺序与键的自然顺序一致，或者根据自定义的比较器顺序。 性能对比 # 操作 HashMap LinkedHashMap TreeMap 添加操作 O(1) O(1) O(logN) 删除操作 O(1) O(1) O(logN) 查找操作 O(1) O(1) O(logN) 内存使用 小 中 大 排序需求 无 无 有 遍历 o(n) o(n) o(n) 空间复杂度 o(n) o(n)+链表开销 o(n) +树结构开销 HashMap类性能高，适合大多数场景。 LinkedHashMap类性能中等，适合需要保持插入顺序的场景或实现lru缓存场景。 TreeMap类性能低，适合需要排序和范围查询的场景。 Map使用建议 # 使用接口类型声明变量：Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 重写equals()和hashCode()方法，以实现自定义的比较逻辑。 使用不可变对象作为键值，避免重复创建对象。 合理设置初始容量避免频繁扩容 使用computeIfAbsent()方法，避免重复创建对象。 在多线程环境使用ConcurrentHashMap类。 遍历时不要修改map结构 过度使用treemap，可能会导致性能下降。 Queue 接口 # 主要特点\n队列是一种先进先出（FIFO）的数据结构，即先进入的元素先出。 双端操作：支持在队头和队尾进行操作。 多种实现：LinkedList、ArrayDeque、PriorityQueue 线程安全选项：普通queue实现是线程不安全的。 主要方法 # 方法 描述 异常处理 add(E e) 向队尾添加元素，如果队列已满，则抛出异常 IllegalStateException offer(E e) 向队尾添加元素，如果队列已满，则返回false remove() 删除并返回队头元素，如果队列为空，则抛出异常 NoSuchElementException poll() 删除并返回队头元素，如果队列为空，则返回null element() 返回队头元素，但不删除，如果队列为空，则抛出异常 NoSuchElementException peek() 返回队头元素，但不删除，如果队列为空，则返回null LinkedList 实现类 # LinkedList类基于双向链表实现，支持在队头和队尾进行操作，支持null元素。 插入删除效率高，内存动态分配 频繁插入删除操作的场景 ArrayDeque 实现类 # ArrayDeque类基于动态数组实现，支持在队头和队尾进行操作，不支持null元素。 插入删除效率高，内存连续分配 一般队列操作的首选。 PriorityQueue 实现类 # PriorityQueue类基于二叉堆实现，支持在队头和队尾进行操作，不支持null元素。 自动按优先级排序 适合优先级队列场景 选择建议 # 一般用途：ArrayDeque 需要null元素：LinkedList 优先级队列：PriorityQueue 线程安全：ArrayBlockingQueue 或 LinkedBlockingQueue 优先使用offer/poll/peek：这些方法提供更好的错误处理 选择合适的实现类：根据具体需求选择合适的实现； 考虑线程安全：多线程环境下使用并发安全的实现； 合理设置容量：对于有界队列，设置合适的容量限制 ArrayDeque和PriorityQueue不支持null元素; LinkedList在某些场景下性能较差 PriorityQueue的内部排序会消耗额外资源 实际应用场景 # 任务调度系统：使用PriorityQueue实现优先级队列 广度优先搜索（bfs）：使用linkedlist实现队列 缓冲区管理：使用linkedlist实现循环缓冲区。 Iterator 接口 # Iterator迭代器是java集合框架中用于遍历集合元素的标准接口，它提供了一种统一的方式来访问集合中的元素，不需要了解集合的内部结构。Iterator模式是一种设计模式，它将遍历逻辑从集合类中分离出来，使得遍历操作更灵活和安全。\n核心优势\n统一访问接口：Iterator接口定义了访问集合元素的标准接口，无论集合是数组、链表、树、集合等，都可以使用Iterator接口进行遍历。 安全删除：Iterator接口提供了remove()方法，用于删除当前迭代器指向的元素。 fail-fast机制：Iterator接口的fail-fast机制，即在遍历过程中如果集合被修改，则抛出ConcurrentModificationException异常。 内存效率：不需要额外的索引变量，适合大型集合。 Iterator接口方法 # 方法 描述 boolean hasNext() 判断集合中是否有下一个元素 E next() 返回集合中的下一个元素 void remove() 删除当前迭代器指向的元素 单向遍历（只能向前） 适用于所有collection子类 支持安全删除操作 fail-fast机制保证线程安全 ListIterator 接口 # ListIterator接口是Iterator接口的子接口，它扩展了Iterator接口，提供了额外的方法，用于双向遍历列表。ListIterator接口提供了hasPrevious()、previous()、nextIndex()和previousIndex()方法，用于获取当前迭代器的位置。\n双向遍历（向前和向后） 仅适用于List集合 支持安全删除、添加、修改操作 提供索引信息 增强for循环 # 在Java中，增强for循环（for-each loop）是java 5中引入的一种语法糖，用于遍历数组或集合中的元素。它的主要作用是简化迭代过程，并提高代码可读性。\n语法：for(元素类型 变量名 : 数组或集合) {} 适用于只读遍历 编译时自动转换为Iterator 不能在遍历中删除或添加元素 对于基本数据类型数组，修改循环变量不会影响原数组 只能单向遍历。 遍历方式性能比较 # 遍历方式 适用集合 ArrayList性能 LinkedList性能 可读性 功能特点 普通for循环 所有collection子类 快 慢 高 支持索引操作,可修改 增强for循环 所有collection子类 快 慢 高 简单语法，不支持索引操作，只读遍历 Iterator 所有collection子类 快 慢 高 支持安全删除操作 ListIterator List集合 快 慢 中 支持双向遍历 StreamAPI 所有collection子类 快 慢 高 函数式编程风格，支持并行处理 ArrayList:支持随机访问，传统for循环性能最佳； LinkedList:链表结构，索引访问需要遍历，Iterator效率较高； HashSet/TreeSet:不支持索引访问，只能使用Iterator或增强for循环遍历； 大数据集：性能差异更加明显，选择合适的遍历方式很重要。 使用removeIf()方法删除满足条件的元素，避免使用传统for循环删除。 什么时候使用Iterator而不是增强for循环 # 当需要在遍历过程中删除元素时，或者需要更精细的遍历控制时，应该使用Iterator接口。增强for循环只适合只读遍历。\nListIterator和Iterator的区别 # ListIterator：仅适用于List集合，提供双向遍历和修改操作。 Iterator：适用于所有collection子类，提供单向遍历和安全删除操作。 为什么LinkedList不应该使用索引访问 # LinkedList是链表结构，索引访问需要从头开始遍历到指定位置，时间复杂度为O(n)。在循环中使用索引访问会导致o(n^2)的时间复杂度，性能很差。\n增强for循环到内部实现是什么？ # 增强for循环在编译时会被转换成Iterator迭代器，因此它的性能与Iterator相同。内部实现是基于迭代器（Iterator）的，通过自动处理迭代细节简化代码。核心机制是遍历可迭代对象（如集合或数组）时，隐式调用iterator().next()方法获取元素。\n不能修改集合结构的原因是：迭代器的fail-fast机制：增强for循环依赖集合的迭代器，而迭代器内部维护一个expectedModCount变量（记录集合结构的修改次数），若在遍历过程中直接修改集合（如调用list.add()或者list.remove()），会导致迭代器的expectedModCount与集合实际modCount不一致，触发ConcurrentModificationException异常。\n","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base09/","section":"全部文章","summary":"","title":"Java 集合框架","type":"posts"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","section":"Tags","summary":"","title":"Java集合框架","type":"tags"},{"content":"Java 异常处理：异常基础、异常处理、throw和throws、自定义异常、try-with-resources。\n异常基础 # 异常是指在程序运行过程中发生的错误或异常情况，导致程序中断或异常终止。Java 异常处理机制提供了一种结构化的方式来处理异常，确保程序的正常运行和稳定性。\n异常的作用\n错误报告：提供详细的错误信息； 程序健壮性：防止程序因错误而崩溃； 错误恢复：允许程序从错误中恢复； 调试支持：提供堆栈跟踪信息。 异常分类 # 所有异常都继承自 java.lang.Throwable 类，分为两种类型：\n检查异常（Checked Exception）：必须在方法签名中声明或捕获，否则编译错误。IOException、SQLException等。 运行时异常（Runtime Exception）：无需在方法签名中声明或捕获，运行时可能抛出。NullPointerException、ArrayIndexOutOfBoundsException等。 错误（Error）：表示严重的错误，通常由Java虚拟机（JVM）抛出，程序无法处理。StackOverflowError、OutOfMemoryError等。 ⚠️性能考虑\n异常处理有开销：异常对象创建需要生成堆栈跟踪； 不要用异常控制流程：异常应该用于异常情况 避免频繁抛出异常：在循环中进行预检查。 什么时候应该捕获异常 # 能够合理地处理异常或者需要进行资源清理时。\n检查异常和运行时异常的区别 # 检查异常必须在编译时处理，运行时异常可以选择处理。\n是否应该捕获Error # 不应该捕获Error，因为Error表示严重的错误，通常由JVM抛出，程序无法处理。\n如何选择抛出异常还是返回错误码 # 抛出异常：当异常是可恢复的或需要进行错误处理时； 返回错误码：当异常是不可恢复的或不需要进行错误处理时。 异常处理 # 异常处理是java编程中的重要概念，它允许程序在运行时优雅地处理错误情况。java异常处理机制基于try-catch-finally语句块，用于捕获和处理异常。异常是指在程序运行过程中发生的错误或异常情况，导致程序中断或异常终止。java中的异常是一个对象，它封装了错误信息和发生错误时的程序状态。\n异常处理流程 # 程序执行到可能抛出异常的语句时，会检查是否有匹配的异常处理程序； 如果有匹配的异常处理程序，会跳转到异常处理程序执行； 如果没有匹配的异常处理程序，会向上层调用栈查找； 如果最终没有合适的异常处理程序，程序会终止运行。 try-catch-finally基本语法\ntry { // 可能抛出异常的代码 } catch (ExceptionType1 e1) { // 处理 ExceptionType1 异常的代码 } catch (ExceptionType2 e2) { // 处理 ExceptionType2 异常的代码 } finally { // 无论是否发生异常，都会执行的代码 } 异常处理执行顺序 # 程序执行到try语句块中的代码； 如果发生异常，会跳转到匹配的catch语句块执行； 如果没有匹配的catch语句块，会向上层调用栈查找； 如果最终没有合适的异常处理程序，程序会终止运行； 无论是否发生异常，finally语句块中的代码都会执行。 后续代码：继续执行try-catch-finally语句块后面的代码。 自定义异常 # 自定义异常是指根据程序的业务逻辑需求，创建自己的异常类。自定义异常可以提供更具体的错误信息和异常类型，方便程序开发者进行错误处理和调试。\n自定义异常的步骤\n创建一个新的异常类，继承自 Exception 或 RuntimeException； 添加构造方法，用于设置异常信息； 可以添加其他自定义方法，用于获取异常信息或进行其他操作。 //自定义检查异常 public class CustomCheckedException extends Exception { public CustomCheckedException(String message) { super(message); } } //自定义运行时异常 public class CustomRuntimeException extends RuntimeException { public CustomRuntimeException(String message) { super(message); } } //使用自定义异常 try { // 可能抛出自定义异常的代码 } catch (CustomCheckedException e) { // 处理自定义检查异常的代码 } catch (CustomRuntimeException e) { // 处理自定义运行时异常的代码 } throw 和 throws # throw的特点\nthrow用于在方法中手动抛出异常； 可以抛出任何类型的异常，包括检查异常和运行时异常； 抛出异常后，方法会立即停止执行，后续代码不会被执行； 可以在catch语句块中抛出异常，将异常传递给上层调用栈处理。 throws的特点：\nthrows用于在方法签名中声明可能抛出的异常； 可以声明多个异常，用逗号分隔； 调用该方法的代码必须处理声明的异常，或者继续声明抛出； 运行时异常无需在方法签名中声明，但是检查异常必须声明。（编译器会检查异常是否被正确处理） throw和throws的区别\n特性 throw throws 位置 方法体内部 方法签名 作用 手动抛出异常 声明可能抛出的异常 异常类型 可以抛出任何类型的异常 必须声明检查异常 异常处理 必须在调用方法的代码中处理异常 调用方法的代码可以选择处理或继续声明抛出 数量 可以抛出多个异常 只能声明一个异常 执行时机 运行时执行 编译时检查 后续代码 继续执行try-catch-finally语句块后面的代码(之后的代码不执行) 后续代码依赖于异常是否被处理（正常执行） 异常处理的最佳实践 # 只捕获必要的异常：只捕获能够处理的异常，避免捕获所有异常； 异常处理代码要简洁明了：异常处理代码应该只包含必要的逻辑，避免复杂的处理流程； 避免在循环中抛出异常：在循环中抛出异常会导致性能问题，应该避免在循环中抛出异常； 记录异常信息：在捕获异常时，应该记录异常信息，方便后续调试和分析。 尽早处理异常：在可能发生异常的地方，尽早捕获并处理异常，避免异常传播到上层调用栈。 尽早抛出异常，尽晚捕获异常。 异常处理代码要与业务逻辑分离：异常处理代码应该与业务逻辑分离，避免将异常处理代码嵌入到业务逻辑中。 异常类型选择指南 # 检查异常（Checked Exception）：继承自 Exception 类的异常，必须在方法签名中声明，或者在方法体中使用 try-catch 语句捕获处理。必须在方法签名中声明或捕获异常，如IOException、SQLException等。 运行时异常（Runtime Exception）：继承自 RuntimeException 类的异常，无需在方法签名中声明，但是可以在方法体中使用 try-catch 语句捕获处理。不强制要求声明或捕获，如NullPointerException、ArrayIndexOutOfBoundsException等。 错误（Error）：继承自 Error 类的异常，通常表示严重的系统错误，不应该被捕获和处理。不建议在业务逻辑中捕获或处理错误异常，如OutOfMemoryError、StackOverflowError等。 对于可恢复的错误，使用异常检查机制，如IOException、SQLException等。 对于不可恢复的错误（编程错误、逻辑错误等），使用运行时异常，如NullPointerException、ArrayIndexOutOfBoundsException等。 自定义异常：根据业务逻辑需求，创建自定义异常类，继承自Exception或RuntimeException。 不要为简单的参数验证使用检查异常：检查异常用于处理可恢复的错误，而参数验证是一种简单的检查，不应该使用检查异常。 优先使用标准异常类型 必要时创建自定义异常类。 throw后面跟异常对象（用于抛出异常），throws后面跟异常类型（用于声明异常）。 异常会沿着调用栈向上传播，直到被捕获或者达到程序顶层。 保证异常链完整，不要丢失原始异常信息。 try-with-resource # try-with-resource是Java 7引入的一种异常处理机制，用于自动关闭实现了AutoCloseable接口的资源，如文件流、数据库连接等。它可以确保资源在使用完毕后被正确关闭，避免资源泄漏和内存泄漏问题。\n在try-with-resource中声明的变量是隐式final的。\n核心优势\n自动资源管理：无需手动调用close方法关闭资源，try-with-resource会自动关闭资源，确保资源在使用完毕后被正确关闭。 异常处理安全：try-with-resource可以捕获并处理异常，确保资源在关闭时不会抛出异常。 代码简洁：使用try-with-resource可以使代码更加简洁，避免了手动关闭资源的繁琐操作。 资源关闭顺序：try-with-resource会按照声明的顺序关闭资源，确保资源的关闭顺序是正确的。 异常链完整：try-with-resource会将原始异常信息传递给异常处理代码，确保异常链完整，方便调试和分析。 避免资源泄漏：try-with-resource可以避免由于忘记关闭资源而导致的资源泄漏问题。 基本语法\ntry(Resource r = new Resource()){ // 使用资源 } catch (Exception e) { // 处理异常 } //多个资源 try(Resource r1 = new Resource(); Resource r2 = new Resource()){ // 使用资源 } catch (Exception e) { // 处理异常 } AutoCloseable接口 # AutoCloseable接口是Java 7引入的一个函数式接口，用于表示实现了自动关闭资源的对象。它定义了一个close方法，用于关闭资源。\npublic interface AutoCloseable { void close() throws Exception; } 要在try-with-resource语句中使用的资源，必须实现AutoCloseable接口。\n⚠️注意 实现AutoCloseable接口时，close方法应该是幂等的，即多次调用close方法应该与调用一次close方法的效果相同。\n异常处理规则 # try-with-resource语句中可以包含多个资源，每个资源之间用分号分隔。 资源的关闭顺序与声明顺序相反，即最后声明的资源最先关闭。 资源的close方法会在try语句执行完毕后自动调用，无论是否发生异常。 如果try语句中发生异常，close方法会在异常处理代码执行完毕后调用。 如果close方法抛出异常，try-with-resource语句会将close方法抛出的异常添加到原始异常中，确保异常链完整。 可以在try-with-resource语句中使用多个catch子句，分别处理不同类型的异常。 抑制异常：close方法抛出的异常会被添加到主异常的抑制异常列表中。 异常传播：即使colse抛出异常，所有资源仍然会尝试关闭。 try-catch-finally \u0026amp; try-with-resource区别 # 特性 try-catch-finally try-with-resource 资源关闭 手动调用close方法关闭资源 自动关闭资源 异常处理 手动处理异常 自动处理异常 代码简洁 繁琐 简洁 资源关闭顺序 手动指定 自动指定 异常链完整 不完整 完整 避免资源泄漏 可能 绝对 空指针检查 手动检查 自动检查，编译器保证 性能 无影响 无影响 可以在try-with-resource中使用null吗 # 不可以，如果资源初始化返回null，会在进入try块之前抛出NullPointerException异常。\n资源关闭的顺序是什么？ # 资源的关闭顺序与声明顺序相反，即最后声明的资源最先关闭。\n可以在try块外访问资源吗 # 不可以，在try-with-resource语句中声明的资源只能在try块中访问。\nclose方法会被调用多次吗 # 不会，每个资源的close方法只会被调用一次，即使手动调用过close方法也不会再次调用。\n","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base08/","section":"全部文章","summary":"","title":"Java 异常处理","type":"posts"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","section":"Tags","summary":"","title":"Java异常处理","type":"tags"},{"content":"Java 高级特性：内部类和嵌套类、枚举类型（enum）、递归、反射、注解（annotation）、泛型（generics）。\n内部类和嵌套类 # 内部类是定义在另一个类内部的类。嵌套类是指在一个类的内部定义的类，可以分为静态嵌套类和非静态嵌套类（即内部类）。内部类可以访问外部类的成员变量和方法，而静态嵌套类则不能。\n成员内部类：定义在外部类的非静态类，可以访问外部类的所有成员；持有外部类的引用；不能定义静态成员（除常量）。 静态嵌套类：使用static修饰的类；只能访问外部类的静态成员；不持有外部类的引用；可以定义静态成员；可以独立于外部类对象存在。不会阻止外部类被垃圾回收。 局部内部类：定义在方法或代码块中的类；作用域仅限于定义它的方法或代码块；可以访问方法的final或effectively final变量。 匿名内部类：没有名字的内部类；通常用于简化代码，尤其是在实现接口或继承类时。适合简单的一次性实现，广泛用于事件处理和回调。 成员内部类示例：\nclass Outer { private int outerField = 10; class Inner { void display() { System.out.println(\u0026#34;Outer field: \u0026#34; + outerField); } } } // 使用成员内部类 Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); inner.display(); outer.createInner(); 静态嵌套类示例：\nclass Outer { static class StaticNested { void display() { System.out.println(\u0026#34;Static nested class\u0026#34;); } } } // 使用静态嵌套类 Outer.StaticNested nested = new Outer.StaticNested(); nested.display(); 局部内部类示例：\nclass Outer { void method() { class LocalInner { void display() { System.out.println(\u0026#34;Local inner class\u0026#34;); } } LocalInner localInner = new LocalInner(); localInner.display(); } } // 使用局部内部类 Outer outer = new Outer(); outer.method(); LocalInner localInner = outer.new LocalInner(); localInner.display(); ⚠️局部内部类只能访问final或事实上的final局部变量。这是因为局部变量在方法结束后会被销毁，而内部类可能在方法结束后仍然存在，因此只能访问那些不会改变的变量。\n匿名内部类示例：\ninterface Greeting { void sayHello(); } // 使用匿名内部类 Greeting greeting = new Greeting() { @Override public void sayHello() { System.out.println(\u0026#34;Hello from anonymous class!\u0026#34;); } }; greeting.sayHello(); 匿名类使用场景\n事件处理：gui编程中的事件监听器 回调函数：异步操作的回调实现 函数式接口：简单的函数式接口实现（java8之前） 一次性实现：只使用一次的简单实现 内部类类型对比\n内部类类型 访问外部类成员 定义静态成员 创建对象 成员内部类 可以访问外部类的实例成员、静态成员、持有外部类引用、使用访问修饰符 不能定义静态成员变量和方法，不可以独立创建对象，不可以访问局部变量 创建对象时需要外部类对象 静态嵌套类 只能访问外部类的静态成员变量和方法，可以独立创建对象，可以访问修饰符 可以定义静态成员变量和方法 创建对象时不需要外部类对象 局部内部类 可以访问外部类实例成员、静态成员、持有外部类引用、可以访问局部变量 不能定义静态成员变量和方法，不能独立创建对象、不能使用访问修饰符 创建对象时需要外部类对象 匿名内部类 可以访问外部类中的所有成员变量和方法 不能定义静态成员变量和方法 创建对象时需要外部类对象 使用内部类建议：\n不需要访问外部类实例时使用静态嵌套类 简单的接口实现使用匿名类 紧密关联的辅助类使用成员内部类 方法内的临时类使用局部内部类 需要临时创建对象使用匿名类 迭代器模式和建造者模式（静态嵌套类）。 ⚠️性能和内存考虑\n内存泄漏：成员内部类持有外部类引用，可能导致外部类无法被垃圾回收； 创建开销：静态嵌套类创建开销最小，匿名类可能较大。 内存效率：静态嵌套类\u0026gt;局部内部类\u0026gt;成员内部类\u0026gt;匿名类 访问效率：静态嵌套类\u0026gt;成员内部类\u0026gt;匿名类\u0026gt;局部内部类(直接访问比通过引用访问更高效) 枚举类型（enum） # 枚举类型（enum）是一种特殊的类，是java5新特性，用于定义一组常量。枚举类型提供了一种更安全的方式来处理常量，并且可以提供一些额外的功能，如枚举类型的方法、构造函数、继承等。\n优势：\n类型安全：编译时检查，避免无效值； 可读性强：语义明确，代码更易理解； 功能丰富：可以添加属性、方法和构造函数； 内置方法：values()、valueOf()、ordinal()、name()、toString()。 单例保证：每个枚举常量都是单例。 枚举类型实现原理：枚举类型是一个类，继承了Enum类，枚举类型中的每个常量都是一个枚举对象，枚举对象在编译时会被替换为对应的常量值。\n枚举内置方法\nvalues()：返回枚举类型的所有常量，返回的是一个数组； valueOf(String name)：返回指定名称的枚举常量，如果找不到则抛出异常； ordinal()：返回枚举常量的索引，索引从0开始； name()：返回枚举常量的名称； toString()：返回枚举常量的字符串表示，默认返回名称。 equals()：比较两个枚举对象是否相等，相等则返回true； hashCode()：返回枚举常量的哈希码值，默认返回名称的哈希码值； compareTo()：比较两个枚举对象，返回值小于0表示当前对象小于参数对象，等于0表示当前对象等于参数对象，大于0表示当前对象大于参数对象。 ⚠️注意事项\nordinal()方法返回的是声明顺序，不建议用于业务逻辑； -valueOf()方法区分大小写，传入错误名称会抛出异常； 枚举实现了Comparable接口，默认情况下枚举对象会按照声明顺序进行排序，如果需要自定义排序规则，需要实现Comparable接口并重写compareTo()方法。 枚举构造方法必须是private，可以省略private，这确保了枚举常量只能在枚举内部创建，维护了枚举的单例特性。 枚举常量不能使用 \u0026gt; 和 \u0026lt; 直接比较，需要使用compareTo()方法进行比较。枚举支持 == 和equals()比较，并且实现了Comparable接口，因此可以进行排序。 策略模式（Strategy Pattern）是一种软件设计模式，它允许在运行时动态选择算法或者策略。策略模式将算法封装在独立的对象中，并使它们可以相互替换。 策略模式在java中的实现：\npublic enum DiscountStrategy { NONE{ public double apply(double price) { return price; } }, REGULAR{ public double apply(double price) { return price * 0.9; } }, LONG_TERM{ public double apply(double price) { return price * 0.85; } }; public abstract double apply(double price); } 策略模式使用场景：\n使用枚举替代常量值 为枚举添加有意义的方法 使用枚举实现策略模式 合理使用构造方法 递归(Recursion) # 递归是一种强大的编程技术，函数调用自身来解决更小规模的相同问题。\n❗️递归的核心要素：\n基础情况：递归的终止条件，防止无限递归； 递归情况：函数调用自身的情况； 问题分解：将大问题分解为相同类型的小问题； 结果合并：将子问题的结果合并得到最终答案。 递归优化技术：\n记忆化：递归调用的结果保存起来，下次调用时直接返回结果，避免重复计算。 尾递归：递归调用必须位于函数的末尾，递归调用必须返回结果。 动态规划转换：将递归问题转换为动态规划问题。 迭代：递归调用改为迭代调用。 剪枝：递归调用时，根据当前状态判断是否需要继续递归调用。 贪心算法：递归调用时，根据当前状态选择最佳解。 回溯算法：递归调用时，根据当前状态选择所有可能的解，并返回最佳解。 递归树：递归调用时，将递归调用过程画成树形结构，方便理解。 递归树剪枝：递归调用时，根据递归树剪枝算法，剪枝掉不需要的递归调用。 递归树优化：递归调用时，根据递归树优化算法，优化递归调用。 反射(Reflection) # 反射机制允许程序在运行期间获取任意一个类的内部信息，并能够操作任意一个对象的内部属性以及方法。这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。\n反射主要用途\n运行时类型检查（在运行时确定对象的类型，获取类的详细信息，包括类名、包名、父类、接口等）； 动态对象创建（根据类名动态创建对象实例，支持不同参数等构造器调用）； 动态方法调用（在运行期间调用对象的方法，包括私有方法，实现灵活的程序控制）； 动态字段访问（在运行期间访问对象字段，包括私有字段，实现灵活的程序控制）。 反射核心类\nClass：代表一个类，Class对象表示某个类或接口，Class对象是所有Class对象的基类。Class对象是反射的起点。 Field：代表类的成员变量，Field对象表示某个类的成员变量，Field对象是所有Field对象的基类。 Method：代表类的方法，Method对象表示某个类的方法，Method对象是所有Method对象的基类。 Constructor：代表类的构造器，Constructor对象表示某个类的构造器，Constructor对象是所有Constructor对象的基类。 获取Class对象 # Class.forName(\u0026ldquo;包名.类名\u0026rdquo;)：动态加载类，适用于类名以字符串形式提供的情况。 对象.getClass()：运行时获取，适用于已有对象实例的情况。 类名.class：编译时就确定，效率最高，适用于已知具体类是情况。 字段反射操作 # Class clazz = FieldReflect.class; //获取所有字段(包括继承的) Field[] fields = clazz.getFields(); //获取当前类字段(不包括继承的) Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { System.out.println(field.getName()); System.out.println(field.getType()); } //访问公共字段 Field field = clazz.getField(\u0026#34;name\u0026#34;); //访问私有字段 Field field = clazz.getDeclaredField(\u0026#34;age\u0026#34;); field.setAccessible(true);//设置可访问 field.set(field, \u0026#34;张三\u0026#34;); //访问静态字段 Field field = clazz.getDeclaredField(\u0026#34;age\u0026#34;); 方法反射操作 # //调用公共方法 Method method = clazz.getMethod(\u0026#34;getName\u0026#34;); method.invoke(method); //调用私有方法 Method method = clazz.getDeclaredMethod(\u0026#34;getName\u0026#34;); method.setAccessible(true); method.invoke(method); //调用静态方法 Method method = clazz.getMethod(\u0026#34;getName\u0026#34;); method.invoke(null); //调用重载方法(带参数) Method method = clazz.getMethod(\u0026#34;getName\u0026#34;, String.class); method.invoke(method, \u0026#34;张三\u0026#34;); Method method = clazz.getMethod(\u0026#34;getName\u0026#34;, int.class); method.invoke(method, 18); 构造器反射操作 # ConstructionReflection //使用无参构造器 Constructor constructor = clazz.getConstructor(); Object obj = constructor.newInstance(); //使用单参构造器 Constructor constructor = clazz.getConstructor(String.class); Object obj = constructor.newInstance(\u0026#34;张三\u0026#34;); //使用多参构造器 Constructor constructor = clazz.getConstructor(String.class, int.class); Object obj = constructor.newInstance(\u0026#34;张三\u0026#34;, 18); //使用私有构造器 Constructor constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true); Object obj = constructor.newInstance(\u0026#34;张三\u0026#34;); System.out.println(\u0026#34;私有构造器对象：\u0026#34; + ((ConstructionReflection)obj).getInfo()); 反射最佳实践\n谨慎使用反射，优先考虑面向对象编程方式； 反射操作要进行异常处理，捕获相关的反射异常； 使用setAccessible(true)时要注意考虑安全性问题； 反射操作性能较低，避免在性能敏感的代码中频繁使用反射； 缓存反射获取的Class\\Method\\Field对象，避免每次获取对象; 在框架中合理使用反射，提供灵活性和扩展性。 反射操作无法在编译时进行类型检查，可能会导致运行时错误。 反射使用场景\n配置文件解析 框架开发 动态代理 测试框架 调试工具：ide调试器使用反射显示对象的内部状态和结构信息； 插件系统：动态加载和执行插件代码，实现可扩展的应用架构。 序列化：json和xml序列化库使用反射将对象转化为字符串格式。 反射的缺点\n反射性能问题：反射操作耗时，反射操作的效率比直接操作对象效率低。 破坏封装性 代码可读性差 编译时无法进行类型检查。 注解（Annotation） # 注解是java5引入的，注解是一种修饰符，注解可以修饰包、类、方法、属性、参数、局部变量，为代码添加元数据的方式。注解本身不会改变程序的执行逻辑，但可以被编译器、开发工具和运行时环境读取和处理。\n注解的作用：\n编译时检查：如@Override检查方法重写是否正确； 代码生成：如Lombok的@Getter@Setter注解，自动生成getter和setter方法； 运行时处理：如Spring的@Component、@Controller、@Service、@Repository注解，自动扫描并注册bean，进行依赖注入； 文档生成：如@Deprecated注解，表示该方法或类已过时，不建议使用。 配置管理：如Spring的@Value注解，用于注入配置文件参数。 Java内置的注解：\n@Override：表示该方法是一个重写方法，用于检查是否正确地重写父类方法； @Deprecated：表示该方法或类已过时，不建议使用； @SuppressWarnings：表示忽略编译警告，如使用过时方法或参数。 @FunctionalInterface：表示该接口是一个函数式接口，用于定义lambda表达式。 @SafeVarargs：表示该方法使用了可变参数，但该参数不会被修改，可以忽略编译警告。 @Test：表示该方法为测试方法，用于单元测试。 自定义注解\n//作者信息注解 @Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface AuthorInfo { String name() default \u0026#34;holly\u0026#34;; String date() default \u0026#34;\u0026#34;; String email() default \u0026#34;\u0026#34;; } //版本信息注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface VersionInfo { String value() default \u0026#34;1.0.0\u0026#34;; String description() default \u0026#34;\u0026#34;; } 元注解\n@Documented：表示注解被javadoc工具所记录 @Retention：表示注解被保留的时间长短(运行时、编译时、类加载时\u0026mdash;SOURCE\\CLASS\\RUNTIME) @Target：表示注解所修饰的对象范围(类、方法、属性、构造器、参数、包、注解\u0026mdash;TYPE\\FIELD\\METHOD) @Inherited：表示注解被子类继承。 注解设计和使用原则\n注解本身没有逻辑，只是为程序员提供一种新的方法，来为程序进行注释。 明确注解的目的和作用域 提供合理的默认值 使用有意义的名称 添加完整的文档说明 考虑性能影响（⚠️反射操作有一定的性能开销，在高频调用的场景中应该考虑缓存注解信息，避免重复的反射操作） 注解使用场景\n数据验证（使用注解标记字段验证规则，如：@NotBlank、@NotNull、@Min、@Max、@Email、@Pattern） 依赖注入（使用注解标记字段，如：@Autowired、@Resource） orm映射（使用注解标记字段，如：@Table、@Column、@Id、@GeneratedValue） web开发（springmvc使用注解标记方法，如：@Controller、@RequestMapping、@RequestParam、@ResponseBody） 序列化（jackson的@JsonProperty注解） 测试（junit的@BeforeClass、@AfterClass、@Before、@After、@Test、@Ignore注解） 泛型（Generics） # 泛型是java5引入的新特性，泛型使得类、接口和方法可以支持任意数据类型。它提供了编译时类型安全检测机制，允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，即所操作的数据类型被指定为一个参数。\n❗️泛型主要优势：\n类型安全：在编译时检查类型错误，避免允许时ClassCastException; 消除类型转换：避免显式类型转换，代码更简洁 代码复用：可以编写一次泛型代码，用于多种数据类型，避免重复编写相似的代码。 提高性能：避免装箱和拆箱操作，直接操作原始数据类型，提高性能。 更好的api设计：使用api更加清晰和易用。 ? 泛型通配符\n通配符类型 语法 说明 使用场景 上界通配符 \u0026lt;? extends T\u0026gt; 表示类型必须是T或T的子类 读取T类型的数据(只能读取，不能写入)生产者 下界通配符 \u0026lt;? super T\u0026gt; 表示类型必须是T或T的父类 写入T类型的数据(只能写入，不能读取) 消费者 无界通配符 \u003c?\u003e 表示类型可以是任意类型 不限制类型 ⚠️PECS原则\n生产者使用上界通配符（\u0026lt;? extends T\u0026gt;）需要从集合（工厂）中读取数据（生产者）get 消费者使用下界通配符（\u0026lt;? super T\u0026gt;）需要向集合中写入数据（消费者）add 无界通配符（\u003c?\u003e）在不确定具体类型时使用。 类型擦除\n泛型类型在编译时会被擦除，替换为其边界类型（如果有）或Object类型。 运行时无法获取泛型的具体类型信息 不能创建泛型数组 不能实例化类型参数 不能使用基本类型作为类型参数 不能在静态上下文中使用类型参数 什么时候使用泛型 # 当需要类型安全、避免类型转换、提高代码重用性时，特别是在集合、工具类和框架开发中；\nextends和super区别 # extends用于读取（生产者）\u0026mdash;-子类或者相同类型，super用于写入（消费者）\u0026mdash;-父类或者相同类型。\n为什么不能创建泛型数组 # 由于类型擦除，运行时无法确定数组的确切类型，可能导致类型安全问题，可以使用List代替数组，或者使用反射创建。\n","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base07/","section":"全部文章","summary":"","title":"Java 高级特性","type":"posts"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/","section":"Tags","summary":"","title":"Java高级特性","type":"tags"},{"content":"Java 面向对象进阶：继承、方法重写、super关键字、final关键字、抽象类和抽象方法、接口（interface）、多态、封装、instanceof关键字。\nJava 继承 # 继承是面向对象编程的一个重要特性，它允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的重用和扩展。\nextends关键字：建立继承关系的关键字；子类获得父类的属性和方法；java只支持单继承；所有类都隐式继承object类 方法重写（override）：子类重新定义父类的方法；使用@override注解标记；方法签名必须完全相同；实现多态的基础 super关键字：访问父类的成员；调用父类的构造方法；调用父类被重写的方法；解决命名冲突 protected修饰符是专门为继承设计的，它允许子类访问父类的成员，但是不允许其他包中的非子类访问。\n子类重写父类方法时，访问修饰符的限制是：子类方法的访问权限不能低于父类方法的访问权限。可以更宽松，但不能更严格。\n子类重写父类方法时，返回值类型需要兼容：可以为父类返回值类型的子类。\n异常声明限制：不能抛出比父类方法更宽泛的异常。\nJava 方法重写 # 方法重写（override）：子类重新定义父类方法；使用@override注解标记；方法签名必须完全相同；实现多态的基础。\n方法重写必须遵循一系列严格的规则，以确保代码的正确性和一致性：\n方法签名必须完全相同：包括方法名称、参数类型和参数顺序。 访问修饰符不能更严格：子类方法的访问权限不能比父类更严格。 返回类型必须相同或者是子类类型：子类方法的返回类型必须与父类方法相同，或者是其子类类型。 异常声明不能更宽泛：子类方法不能抛出比父类更宽泛的检查异常； final方法、static方法和private方法不能被重写。 构造方法不能被重写。 Java super关键字 # super关键字：访问父类的成员；调用父类的构造方法；调用父类被重写方法；解决命名冲突。\n❗️super关键字的主要用途\n调用父类构造方法：使用super(\u0026hellip;)调用父类的构造方法，必须是子类构造方法的第一行代码。 访问父类成员变量（属性）：使用super.成员变量名访问父类的成员变量。 调用父类方法：使用super.方法名(\u0026hellip;)调用父类 ⚠️重要规则 super关键字只能在子类中使用，不能在静态方法中使用，因为静态方法不属于任何实例。 如果没有显式调用super(),编译器会自动插入super()调用父类的无参构造方法。 如果父类没有无参构造方法，子类必须显式调用父类的其他构造方法，否则编译错误。\nsuper 和 this 的区别\n关键字 作用 示例 使用场景 super 访问父类的成员变量和方法，调用父类的构造方法 super.variable, super.method(), super() 在子类中访问或调用父类的成员或构造方法 this 访问当前实例的成员变量和方法 this.variable, this.method() 在子类中访问当前实例的成员变量和方法 super() 调用父类的构造方法 super() 在子类的构造方法中调用父类的构造方法 this() 调用当前类的另一个构造方法 this() 在当前类的构造方法中调用另一个构造方法 Java final 关键字 # final关键字用于声明常量、方法和类，表示不可更改的含义。用于限制继承、重写和重新赋值。它可以修饰类、方法和变量，确保被修饰的元素具有“最终”的特性，不能被改变。\nfinal类：final类不能被继承，不能有子类。（如String类，Integer、Double等包装类） final方法：final方法不能被子类重写，但可以被子类继承和调用。（保证核心重要逻辑不被修改，在模板方法模式中保护关键步骤，编译器可以对final方法进行内联优化） final变量：final变量不能被重新赋值。 final变量类型 初始化时机 特点 应用场景 final静态变量 类加载时(声明时或者静态代码块) 只能赋值一次，通常用大写字母命名（类级别常量，所有实例共享） 定义常量，如数学常量、配置参数等 final实例变量 声明时或者构造函数（对象创建时） 每个对象可以有不同的值（实例级别的常量，每个对象独有） 不可变对象的字段 fina局部常量 使用前任意时机 方法内部常量 临时常量、lambda表达式 final方法参数 方法调用时 方法内部不可修改参数值 保护方法参数不被修改 final修饰引用变量 赋值时 引用地址不可变，但对象内容可变 不可变引用 final常量和变量有什么区别？ # final变量是语法概念，常量是语义概念。final变量一旦赋值就不能更改，而常量是指在程序运行过程中其值不会改变的量。通常使用static final关键字组合来定义常量。\nfinal方法可以被重载吗？ # 可以。final只是防止重写（override），不影响重载。\n为什么String类是final的？ # 为了安全性、性能优化和字符串池的实现。\nfinal变量一定要在声明时初始化吗？ # 不一定。实例final变量可以在构造函数中初始化，静态final变量可以在静态代码块中初始化，局部final变量可以延迟初始化。\nJava 抽象类和抽象方法abstract # 抽象类是不能实例化的类，用于定义子类的通用属性和行为。抽象方法是只有声明没有实现的方法，抽象方法只能存在于抽象类中，必须在子类中重写。\n不能实例化：不能使用new关键字创建抽象类的对象。 可以有构造方法：用于初始化抽象类中的成员变量。 可以包含具体方法：提供通用的实现逻辑。 可以包含抽象方法：强制子类必须提供具体的实现。 可以有成员变量：存储对象的状态信息。 ✅ 什么时候使用抽象类\n多个相关类需要共享代码时 需要提供部分实现，部分留给子类时 需要强制子类实现某些方法时 定义算法骨架，具体步骤由子类实现时 需要在类中定义实例变量时 ❗️常用场景\n框架设计：定义框架的骨架结构，如spring框架中的抽象类； 模板方法模式：定义算法模板，具体步骤由子类实现； 工厂模式：抽象工厂类定义创建对象的接口 数据访问层： 抽象dao类提供通用的数据库操作方法； 业务逻辑层：抽象service类提供业务逻辑方法。 ⚠️重要规则\n合理命名：使用清晰的类名表达抽象概念； 文档注释：为抽象方法提供详细的文档说明 构造方法：提供合适的构造方法初始化通用属性 访问修饰符：合理使用protected让子类访问； 方法设计：抽象方法应该有明确的职责和契约； 单一职责： 每个抽象类应该有明确单一的职责。 抽象类和接口的区别 # 特性 抽象类 接口 关键字 abstract class interface 继承方式 使用extends关键字（单继承） 使用implements关键字（多实现） 方法 可以包含抽象方法和具体方法 只能包含抽象方法（Java 8及以上版本支持默认方法和静态方法） 成员变量 可以有实例变量和静态变量 只能有静态常量 构造方法 可以有构造方法 不能有构造方法 访问修饰符 可以有各种访问修饰符 默认是public，不能有访问修饰符 Java 接口（interface） # 接口是定义类之间契约的工具，规定了类必须实现的方法和行为。接口支持多重继承，允许类实现多个接口。接口是一个完全抽象的类，它只包含常量（public static final）和抽象方法的声明（默认public abstract）。从java8开始，接口可以包含默认（deafult）方法和静态（static）方法。接口定义了类应该做什么，但不规定如何做。\n⚠️ 接口成员的默认修饰符\n所有变量都是public static final（常量）； 所有方法都是public abstract（抽象方法）； 默认方法使用default关键字定义，可以有具体实现； 静态方法使用static关键字定义，可以有具体实现；（属于接口本身，可以通过接口名调用，不能被实现类重写，静态方法必须有方法体，不需要在实现类中实现） Java 多态 # 多态是面向对象编程的三大特性之一，它允许不同类的对象对同一消息作出不同的响应。多态主要通过方法重写和动态绑定来实现的。\n核心思想：“同一个接口，不同实现”，通过父类引用指向子类对象，在运行时根据对象的实际类型来决定调用哪个方法。\n多态实现的条件：\n继承关系：子类继承父类 方法重写：子类重写父类的方法 向上转型：父类引用指向子类对象 //多态的基本示例 Animal animal1 = new Dog(); //向上转型 Animal animal2 = new Cat(); //动态绑定 animal1.makeSound(); //调用Dog类的makeSound方法 animal2.makeSound(); //调用Cat类的makeSound方法 编译时多态（静态绑定）：方法重载（overload），在编译时根据参数类型和数量决定调用哪个方法。 运行时多态（动态绑定）：方法重写（override），在运行时根据对象确定调用哪个方法。 向上转型：将子类对象赋值给父类引用，自动进行的，无需强制转换；（只能访问父类中定义的方法，实际调用的是子类重写的方法（动态绑定）） 向下转型：将父类引用转换为子类对象，需要强制转换，可能会抛出ClassCastException异常。 //向上转型 Animal animal = new Dog(); animal.makeSound(); animal.move(); animal.fetch(); //编译错误，Animal类没有fetch方法 //向下转型 if (animal instanceof Dog) { Dog dog = (Dog) animal; //强制转换 dog.fetch(); //可以调用fetch方法 } Cat cat = (Cat) animal; //可能抛出ClassCastException异常 instanceof运算符：判断对象是否是某个类的实例。（根据对象类型执行不同的逻辑，在处理混合类型集合时进行类型判断，实现类型安全的操作） 运行时类型信息：Java中的对象可以存储任意类型的数据，但是对象本身只知道它存储了什么类型的数据，不能知道它存储的具体对象是什么类型。运行时类型信息（Runtime Type Information）就是指对象在运行时它的类型信息。 动态方法分派：Java在运行时根据对象的实际类型来决定调用哪个方法，这个过程称为动态方法分派（Dynamic Method Dispatch）。 向下转型必须使用instanceof关键字检查类型；如果类型不匹配会抛出ClassCastException;只有在确实需要访问子类特有方法时才使用。 ❗️动态绑定的工作原理\n编译时：检查父类中是否有该方法 运行时：根据对象的实际类型查找方法 如果子类重写了该方法，调用子类的版本 如果没有重写，调用父类的版本 ✅实际应用场景\n图形界面编程 数据库操作 游戏开发 ⚠️注意\n静态方法不支持多态：静态方法在编译时绑定 静态方法不能被继承：静态方法在编译时绑定 私有方法不支持多态：私有方法不能被重写 构造方法不支持多态：构造方法不能被重写 向下转型需谨慎：必须使用instanceof检查类型 方法重写规则：访问修饰符不能更严格 在多态中，父类引用只能访问父类中定义的方法，不能直接访问子类特有的方法，要访问子类特有的方法需要向下转型。 //多态示例 Animal animal = new Dog(); //向上转型 animal引用（Dog对象）既是Dog类型的实例，也是Animal类型的实例（因为继承关系）。 Java 封装 # 封装是面向对象编程的基本特性之一，它将数据（属性）和行为（方法）绑定在一起，并隐藏对象的内部实现细节，只暴露必要的接口给外部使用。封装提高了代码的安全性、可维护性和可扩展性。\n封装的核心思想是“隐藏实现细节，只暴露必要的接口“。这样可以保护对象的内部状态，防止外部代码的不当访问和修改，同时提高代码的安全性和可维护性。\n访问修饰符：使用private、protected、public等修饰符来控制属性和方法的访问权限。 属性：封装的属性，通常使用private修饰符来隐藏属性的实现细节。 方法：封装的方法，通常使用private修饰符来隐藏方法的实现细节。 提供必要的getter和setter方法：通过公共的getter和setter方法来访问和修改私有属性，实现对属性的控制和保护。 在setter方法中进行数据验证。 不变形：对于不应该改变的字段，只提供getter方法，不提供setter方法。 防御性复制：对于可变对象类型的属性，在getter方法中返回属性的副本，而不是直接返回属性本身，防止外部代码修改对象的内部状态。 Java instanceof关键字 # instanceof关键字用于判断一个对象是否是某个类的实例，或者是否实现了某个接口。它返回一个布尔值，表示对象是否属于指定的类型。\nif (object instanceof ClassName) { // object是ClassName类的实例 //object要检查的对象引用 //ClassName要检查的类或接口或数组类型 //返回值：boolean类型，true或false } 基本类型检查\n//创建不同类型的对象 Object obj1 = new String(\u0026#34;Hello\u0026#34;); Object obj2 = new Integer(10); //使用instanceof关键字进行类型检查 System.out.println(obj1 instanceof String); //true System.out.println(obj1 instanceof Object); //true System.out.println(obj2 instanceof Integer); //true System.out.println(obj2 instanceof Number); //true System.out.println(obj2 instanceof String); //false Object obj4 = null; System.out.println(obj4 instanceof Object); //false System.out.println(null instanceof String); //false ⚠️注意\nnull引用：使用instanceof检查null引用时，结果总是false。 继承关系：如果对象是子类的实例，instanceof检查父类时返回true。 接口实现：如果对象实现了某个接口，instanceof检查该接口时返回true。 数组支持：支持对数据类型的检查。 编译时检查：instanceof在编译时进行类型检查，确保类型兼容性。 向下转型：在进行向下转型之前，使用instanceof进行类型检查，防止ClassCastException异常。 优先使用多态，而不是instanceof：过度使用instanceof可能导致代码复杂且难以维护，优先考虑使用多态来实现不同类型对象的行为。 基本数据类型：instanceof不能用于基本数据类型，只能用于引用类型。 可以使用其他方式或者设计模型替代instanceof的使用，例如：\n多态设计：通过方法重写实现不同类型对象的行为，而不是使用instanceof进行类型检查。 设计模式：使用设计模式（如访问者模式）来处理不同类型对象的操作，而不是使用instanceof进行类型检查。 //访问者模式替代instanceof interface ShapeVisitor { void visit(Circle circle); void visit(Rectangle rectangle); } abstract class Shape { abstract void accept(ShapeVisitor visitor); } class Circle extends Shape { @Override void accept(ShapeVisitor visitor) { visitor.visit(this); } } class Rectangle extends Shape { @Override void accept(ShapeVisitor visitor) { visitor.visit(this); } } ","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base06/","section":"全部文章","summary":"","title":"Java 面向对象进阶","type":"posts"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/","section":"Tags","summary":"","title":"面向对象进阶","type":"tags"},{"content":"Java 面向对象基础: 类和对象、方法、构造函数、访问修饰符、this关键字、String字符串、package包。\n类和对象 # 类的基本结构 # 属性（实例变量）、构造方法、实例方法、静态成员。\n类是对象的模版，定义了对象的属性和行为； 对象是类的实例，通过new关键字创建； 构造方法用于初始化对象，可以重载； 实例变量属于对象，静态变量属于类； 封装通过私有属性和公共方法保护数据的安全； getter和setter方法提供受控的数据访问； 良好的类设计遵循单一职责原则； 合理使用访问修饰符控制成员的可见性。 Java 方法 # 为什么需要方法？\n代码复用：避免重复编写相同的代码； 模块化：将复杂问题分解为简单的子问题； 易于维护：修改功能时只需要修改对应的方法； 提高可读性：通过方法名清晰表达代码意图。 参数传递机制 # 传递基本数据类型时，方法接收的是实参值的副本，方法内对参数的修改不会影响原始变量的值； 传递引用数据类型时，方法接收的时对象引用的副本，通过这个引用可以修改对象的内容，但不能改变原始引用指向的对象。 Java 方法重载 # 重载必须满足以下条件之一：\n参数个数不同 参数类型不同 参数顺序不同 仅仅返回值类型不同不能构成方法重载； Java 构造函数 # 构造函数是一种特殊的方法，用于创建和初始化对象。它的名称与类名相同，没有返回值类型（包括void）。\n构造函数在对象创建时自动调用； 可以重载多个构造函数，根据参数不同初始化对象； 如果没有定义构造函数，编译器会自动提供一个默认构造函数； 构造函数可以调用其他构造函数，使用this关键字实现。 构造函数链式调用 # 使用this()调用同类中的其他构造函数； 必须放在构造函数的第一行； 只能在构造函数中调用，不能在普通方法中调用。 参数匹配：调用时必须与构造函数的参数列表匹配，否则会编译错误。 避免循环调用：构造函数不能直接或间接地调用自身，否则会导致无限循环。 代码复用：通过构造函数链式调用，避免重复初始化代码。 构造函数参数验证 # 防止创建无效状态的对象 提供清晰的错误信息 遵循“快速失败”原则，在参数无效时立即抛出异常，而不是在后续代码中处理无效情况。 提高代码的健壮性 Builder模式与构造函数 # 建造者模式\u0026mdash;把复杂对象的创建过程拆解成“可选步骤”，每个步骤都返回当前对象的引用，最后调用build()方法创建对象。（最后一次性产出完整产品） 适用场景：适合复杂不可变的对象（线程安全）\n当一个对象有多个可选参数，而不是所有参数都是必填的时； 当对象的创建过程比较复杂，包含多个步骤时； 当需要创建不同配置的对象时，例如不同的用户角色、不同的产品类型等。 角色：\nproduct类：要创建的复杂对象 builder类：包含创建product对象的方法和设置属性的方法(定义组装步骤的接口/静态内部类) ConcreteBuilder：真正执行组装，保存中间状态 director类：负责调用builder的方法，按照一定的顺序组装对象。 适用于参数较多或可选参数的情况 提供了一种更灵活的初始化对象的方式 可以一步一步地设置对象的属性，而不是在构造函数中一次性设置所有属性 可以在构建过程中添加额外的逻辑，例如验证参数的有效性 可以隐藏对象的内部表示，只暴露必要的方法来设置属性 可以在构建完成后返回一个不可变的对象，确保对象的状态不会被修改 public class User { private String name; private int age; private User(Builder builder) { this.name = builder.name; this.age = builder.age; } public static class Builder { private String name; private int age; public Builder setName(String name) { this.name = name; return this; } public Builder setAge(int age) { this.age = age; return this; } public User build() { return new User(this); } } } User user = new User.Builder() .setName(\u0026#34;张三\u0026#34;) .setAge(18) .build(); 防御性复制 # 防御性复制是指在创建对象时，对传入的参数进行复制，而不是直接引用。适用场景：\n当对象的属性是可变的，而我们不希望外部代码直接修改对象的属性时。 当对象的属性是不可变的，但是我们需要在对象外部修改属性时； 当对象的属性是其他对象的引用，而我们不希望外部代码直接修改引用时。 宁可多new一次，也不把命运交到别人手里。\n防御性复制的实现方式：\n深拷贝：创建一个新的对象，将原对象的所有属性值复制到新对象中。 浅拷贝：创建一个新的对象，将原对象的引用复制到新对象中。 无论采用深拷贝还是浅拷贝，都需要注意循环引用的问题，避免无限循环。 Java 访问修饰符 # 访问控制的重要性：\n保护类的内部实现细节 提供清晰的公共接口 防止不当的外部访问 支持代码的模块化设计 Java 提供了四种访问修饰符，用于控制类、方法和属性的可见性：\npublic：公共的，任何类都可以访问； protected：受保护的，同一个包中的类或者同包和不同包的子类可以访问； default（也称为包级可见性）：没有显式修饰符，同一个包中的类可以访问； private：私有的，只有同一个类中的方法可以访问。 推荐做法：\n最小权限原则：使用最严格的访问修饰符 字段私有化：将字段设为private，通过getter/setter访问 接口公开：公共方法提供清晰的接口 工具方法：使用public static 修饰工具方法 继承支持：使用protected支持子类扩展 包内协作：使用默认访问权限进行包内协作 ⚠️注意事项\n构造方法访访问权限：构造方法的访问权限决定了类的实例化方法 静态成员访问：静态成员的访问权限影响类级别的访问 内部类访问：内部类可以访问外部类的所有成员，包括private 接口成员：接口中的方法默认是public，字段默认是public static final。 ❗️设计建议（访问修饰符的选择影响代码的可维护性和扩展性）\napi设计：公共api应该稳定，避免频繁修改public接口 版本兼容：修改public成员可能破坏向后兼容性 测试友好：考虑测试需求，适当提供包访问权限 文档说明：为public成员提供详细的文档说明 Java this关键字 # ❗️this关键字的核心作用\n对象引用：this代表当前正在执行方法的对象 消除歧义：当成员变量和参数同名时，用this区分 构造方法调用：使用this()调用同一个类的其他构造方法 返回this实现方法的链式调用 ⚠️注意事项\n静态上下文：静态方法和静态代码块中不能使用this 构造方法调用：this()必须是构造方法的第一句 循环调用：避免构造方法之间形成循环调用 性能考虑：this引用本身没有性能开销 代码风格：团队内保持一致的this使用风格 this关键字与其他概念super、static的区别\n概念 作用 使用场景 示例 this 引用当前对象 访问当前对象的成员变量和方法 this.name = name super 引用父类 继承关系中 super.method() static 类级别的成员 不依赖对象实例 static int count Java String字符串 # 核心特性\n不可变性：string对象一旦创建，内部不可修改 字符串池：jvm维护一个字符串常量池来优化内存使用 线程安全：由于不可变性，string天然线程安全 丰富的api：提供大量字符串操作方法 字符串创建方法\n// 使用字面量创建 String str1 = \u0026#34;hello\u0026#34;; // 字符串常量池 String str2 = \u0026#34;hello\u0026#34;; System.out.println(str1 == str2);//true //使用构造方法创建 String str3 = new String(\u0026#34;Hello\u0026#34;); String str4 = new String(\u0026#34;Hello\u0026#34;); //每次都创建新对象 System.out.println(str3 == str4);//false System.out.println(str3.equals(str4));//true //使用字符数组创建 char[] chars = {\u0026#39;H\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;}; String str5 = new String(chars); System.out.println(str5);//Hello 常用方法\nString str = \u0026#34; Hello World \u0026#34;; //长度 int length = str.length(); // 13 //判断是否为空 boolean isEmpty = str.isEmpty(); // false boolean isBlank = str.isBlank(); // false //安全判空方法 if(str != null \u0026amp;\u0026amp; !str.isEmpty()){ //处理字符串 } //字符访问 char ch = str.charAt(0); // \u0026#39; \u0026#39; //查找 int index1 = str.indexOf(\u0026#34;World\u0026#34;); // 7 int index2 = str.lastIndexOf(\u0026#34;World\u0026#34;); // 7 //字符串比较 boolean equals = str.equals(\u0026#34; Hello World \u0026#34;); // true boolean equalsIgnoreCase = str.equalsIgnoreCase(\u0026#34; hello world \u0026#34;); // true int compare = str.compareTo(\u0026#34; Hello Java \u0026#34;); // \u0026gt;0 //包含判断 boolean contains = str.contains(\u0026#34;World\u0026#34;); // true boolean startsWith = str.startsWith(\u0026#34; Hello\u0026#34;); // true boolean endsWith = str.endsWith(\u0026#34;World \u0026#34;); // true //子字符串 String sub = str.substring(1, 6); // \u0026#34;Hello\u0026#34; //替换 String replaced = str.replace(\u0026#34;World\u0026#34;, \u0026#34;Java\u0026#34;); // \u0026#34; Hello Java \u0026#34; String replacedAll = str.replaceAll(\u0026#34; \u0026#34;, \u0026#34;_\u0026#34;); // \u0026#34;_Hello_World_\u0026#34; //转换大小写 String upper = str.toUpperCase(); // \u0026#34; HELLO WORLD \u0026#34; String lower = str.toLowerCase(); // \u0026#34; hello world \u0026#34; //首字母大写自定义方法 public static String capitalize(String input) { if (input == null || input.isEmpty()) { return input; } return input.substring(0, 1).toUpperCase() + input.substring(1).toLowerCase(); } //去除空白 String trimmed = str.trim(); // \u0026#34;Hello World\u0026#34; String stripped = str.strip(); // \u0026#34;Hello World\u0026#34; //拆分 String[] parts = str.trim().split(\u0026#34; \u0026#34;); // [\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;] //连接 String joined = String.join(\u0026#34;-\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;); // \u0026#34;Hello-World\u0026#34; //使用StringBuilder进行字符串拼接 StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; \u0026#34;); sb.append(\u0026#34;World\u0026#34;); String result = sb.toString(); // \u0026#34;Hello World\u0026#34; 字符串池 # 字符串池是jvm在堆内存中维护的一个特殊区域，用于存储字符串字面量，String str = \u0026quot;hello\u0026quot;，避免重复创建相同的字符串对象，从而节省内存。\nString str1 = \u0026#34;hello\u0026#34;; // 存储在字符串池中 String str2 = \u0026#34;hello\u0026#34;; // 复用字符串池中的对象 System.out.println(str1 == str2); // true //new关键字创建的字符串不在字符串池中 String str3 = new String(\u0026#34;hello\u0026#34;); System.out.println(str1 == str3); // false //将new创建的字符串放入字符串池 String str4 = str3.intern(); System.out.println(str1 == str4); // true 线程安全：字符串对象是线程安全的，因为字符串对象是immutable的，字符串对象本身是线程安全的，字符串对象中的内容是线程不安全的。\nString vs StringBuilder vs StringBuffer # 特性 String StringBuilder StringBuffer 可变性 不可变 可变 可变 线程安全 线程安全 非线程安全 线程安全 性能 拼接效率低 拼接效率高 拼接效率较高 使用场景 少量字符串操作(字符串不变) 大量字符串拼接（单线程频繁修改） 多线程频繁修改 内存消耗 较高 较低 较低 方法 提供丰富的字符串操作方法 提供append、insert等方法 提供append、insert等方法 // String 示例 String str = \u0026#34;Hello\u0026#34;; str += \u0026#34; World\u0026#34;; // 创建新对象，效率低 // StringBuilder 示例 StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;); // 修改原对象，效率高 String result = sb.toString(); // StringBuffer 示例 StringBuffer sbuf = new StringBuffer(\u0026#34;Hello\u0026#34;); sbuf.append(\u0026#34; World\u0026#34;); // 线程安全的修改 String result2 = sbuf.toString(); 最佳实践\n使用String处理少量字符串操作，避免频繁修改； 使用StringBuilder进行大量字符串拼接，提升性能； 使用StringBuffer在多线程环境下进行字符串修改，确保线程安全； 使用字面量创建字符串，优先使用“hello”，而不是new String(\u0026ldquo;hello\u0026rdquo;)，以利用字符串池优化内存。 使用equals()方法比较字符串内容，避免使用==比较引用地址。 频繁修改时使用StringBuilder或StringBuffer，避免创建大量临时对象。 及时进行空值检查，防止NullPointerException异常。 使用String.format()或MessageFormat进行复杂字符串格式化，提升代码可读性。 为什么 String 是不可变的？ # 安全性：不可变对象更容易保证数据的一致性和完整性，防止外部代码修改对象状态，防止字符串内容被意外修改。 线程安全：不可变对象天然线程安全，多个线程可以安全地访问同一个String对象而无需同步。 性能优化：不可变对象可以被缓存和共享，减少内存开销 字符串池优化：相同内容的字符串可以共享同一个对象 哈希码缓存：不可变对象的哈希码可以缓存，提高哈希表的性能。String的hashCode()方法只需要一次计算，会缓存计算结果，避免重复计算。 使用时候使用 StringBuilder # 需要频繁修改字符串内容 在循环中进行字符串拼接 构建大型字符串 单线程环境下的字符串操作 String.intern() 方法的作用是什么 # 将字符串对象加入到字符串池中 如果池中已经存在相同内容的字符串，返回池中的引用 如果池中不存在，将当前字符串加入池并返回引用 优化内存使用，减少重复字符串对象，但要谨慎使用，避免内存泄漏 ⚠️注意事项\n空值处理：始终检查字符串是否为null，避免NullPointerException异常。 性能考虑：频繁修改字符串时，优先使用StringBuilder或StringBuffer，避免创建大量临时对象。 内存使用：谨慎使用intern()方法，避免过度占用字符串池内存。 字符编码：处理字符串时，注意字符编码问题，确保正确转换和存储。处理文件或网络数据时，注意字符编码问题。 国际化支持：使用Unicode字符集，支持多语言字符串处理。 正则表达式：使用split()和replaceAll()等方法时，注意正则表达式的语法和性能影响。 Java package包 # package 用于定义Java源文件的命名空间，防止命名冲突。\n包声明：使用package关键字声明包名，包名由多个单词组成，单词之间用点隔开。 目录结构：包名对应文件系统中的目录结构，源文件存放在对应的目录下。 域名反向形式命名 如果没有package语句，类属于默认包（default package） 访问修饰符：包级访问修饰符，默认是public 访问修饰符对比 # 修饰符 同一类 同一包 子类 不同包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × ","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base05/","section":"全部文章","summary":"","title":"Java 面向对象基础","type":"posts"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"面向对象基础","type":"tags"},{"content":"Java 流程控制：if-else、switch、循环（for、while、do-while）、跳转语句（break、continue、return）。\nif-else 语句 # 典型应用：根据不同的条件执行不同的代码块。\n用户输入验证：检查用户输入的数据是否符合条件； 权限检查：根据用户的角色或权限执行不同的操作； 游戏逻辑：根据游戏状态执行不同的游戏逻辑； 路由选择：根据不同的条件选择不同的路径执行； 状态机：根据不同的状态执行不同的操作； 数据范围验证：确保数值在有效范围内； 状态判断：根据对象或系统的状态执行不同的逻辑； 错误处理：根据不同的错误类型执行不同的错误处理逻辑，检测错误条件并采取相应的措施，如打印错误信息、记录日志、回滚操作等。 业务逻辑分支：根据业务需求，将复杂的业务逻辑拆分成多个分支，每个分支对应不同的处理逻辑。 性能优化建议\n将最可能为true的条件放在前面（短路求值性能更好）； 避免在条件表达式中进行复杂计算，如调用方法、进行复杂的数学运算等，将其提取到循环外部； 使用局部变量存储重复计算的结果； 考虑使用switch语句替代多个if-else语句，当有多个条件需要判断时，switch语句的性能通常更好； 合理使用逻辑运算符的短路特性； 考虑使用并行处理或多线程来提高循环的执行效率。 switch 语句 # switch支持的类型：byte、short、int、char、枚举类型、从Java 5支持的包装类、从Java 7开始支持的字符串类型。 break 语句：用于跳出 switch 语句，终止执行后续的 case 分支,如果省略break，程序会执行下一个case，这种现象称为“fall-through”。为了避免“fall-through”现象，每个 case 分支结束时都应该添加 break 语句。有时可以巧用fall-through来实现多个 case 分支共享相同的代码逻辑。 default 语句：用于处理没有匹配的 case 分支的情况。default 语句可以放在 switch 语句的任意位置，通常放在最后面。 swtich表达式（java14开始支持）\nString dayType = switch(dayOfWeek) { case MONDAY, FRIDAY, SUNDAY -\u0026gt; \u0026#34;Weekend\u0026#34;; case TUESDAY, WEDNESDAY, THURSDAY -\u0026gt; \u0026#34;Weekday\u0026#34;; default -\u0026gt; \u0026#34;Invalid day\u0026#34;; }; switch 表达式的优势：\n更简洁的语法：switch 表达式使用箭头运算符（-\u0026gt;）来定义每个 case 分支的代码块，而不需要使用大括号 {}，避免fall-through； 更强大的功能：switch 表达式可以返回一个值，而不仅仅是执行代码块； 更安全的类型检查：switch 表达式会在编译时检查 case 分支的类型是否与 switch 表达式的类型兼容，避免了运行时的类型转换错误； 更灵活的分支逻辑：switch 表达式可以使用多个 case 分支共享相同的代码逻辑，而不需要重复编写相同的代码； 使用yield关键字返回复杂表达式的值。 switch 使用建议\n总是使用break：除非故意使用fall-through来实现多个 case 分支共享相同的代码逻辑。 包含default分支：处理未预期的值； 保持case简洁：复杂逻辑提取到方法中； 使用常量：避免魔法数字（直接在代码中使用具体的数值，而不是定义一个常量来表示）； 考虑使用枚举类型：当有多个固定值需要判断时，使用枚举类型可以提高代码的可读性和维护性。 优先使用switch表达式：当需要根据不同的值执行不同的代码逻辑时，优先使用switch表达式，而不是if-else语句。 switch常见错误\n忘记添加break语句：导致“fall-through”现象，执行多个 case 分支的代码； 忘记添加default分支：处理未预期的值，导致程序运行错误； 使用错误的类型：比如float、double。switch 表达式的类型必须与 case 分支的类型兼容，否则会编译错误； 忘记使用yield关键字返回值：在 switch 表达式中，每个 case 分支都必须使用 yield 关键字返回一个值，否则会编译错误。 null值处理：switch 表达式不支持 null 值，因此在使用 switch 表达式时，应该避免将 null 值作为 case 分支的参数。如果需要处理 null 值，应该使用 if-else 语句或 Optional 类来处理。（使用switch之前进行null检查，避免NullPointerException） 在case中声明变量：在 switch 表达式中，每个 case 分支都可以声明变量，但是这些变量只能在该分支中使用，不能在其他分支中使用。 for 语句 # 使用建议\n使用有意义的循环变量名； 避免在循环体内修改循环变量； 合理使用break和continue语句：在循环中，使用break语句可以提前结束循环，而使用continue语句可以跳过当前迭代，继续下一次迭代。 优先使用for-each循环：当不需要访问循环索引时，优先使用for-each循环，而不是传统的for循环。 避免不必要的嵌套循环：嵌套循环会增加代码的复杂性和运行时间，因此应该尽量避免使用嵌套循环。如果需要嵌套循环，应该考虑是否可以将其转换为单循环来实现相同的功能。 在循环外声明不变的变量：如果在循环中不需要修改的变量，应该在循环外部声明，而不是在循环内部声明。这样可以提高代码的可读性和维护性，避免在循环内部修改变量时引入错误。 //不推荐使用 for (int i = 0; i \u0026lt; array.length; i++) { //处理array[i] } //推荐：提前计算length int length = array.length; for (int i = 0; i \u0026lt; length; i++) { //处理array[i] } //更推荐：使用for-each循环 for (int num : array) { //处理num } for-each 语句 # for-each循环和传统for循环的区别\n特性 传统for循环 for-each循环 语法 for (初始化; 循环条件; 迭代操作) for (元素类型 元素变量 : 数组或集合) 访问元素 使用索引访问数组元素 直接访问元素，无需索引 循环变量作用域 循环体内部 循环体内部 循环索引 可以在循环体内使用 不能在循环体内使用 遍历数组或集合 可以遍历数组或集合的所有元素 只能遍历数组或集合的所有元素 遍历范围 可以指定遍历范围（如部分元素） 只能遍历整个数组或集合 代码简洁性 代码相对较长 代码相对较短 适用场景 需要访问数组索引或进行复杂操作时 只需要遍历数组或集合元素时 for-each循环可以遍历所有实现了Iterable接口的类，包括数组、集合等。(List、Set、Queue等集合类，但是不能直接遍历Map，需要通过Map的视图方法keySet()、entrySet()、values()等获取键值对视图，然后遍历视图元素)\nMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; store = new HashMap\u0026lt;\u0026gt;(); store.put(\u0026#34;水果\u0026#34;, Arrays.asList(\u0026#34;苹果\u0026#34;, \u0026#34;香蕉\u0026#34;, \u0026#34;橙子\u0026#34;)); store.put(\u0026#34;蔬菜\u0026#34;, Arrays.asList(\u0026#34;胡萝卜\u0026#34;, \u0026#34;西红柿\u0026#34;, \u0026#34;茄子\u0026#34;)); for (Map.Entry\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; category : store.entrySet()) { System.out.println(category.getKey() + \u0026#34;包含\u0026#34;); for (String item : category.getValue()){ System.out.println(\u0026#34; - \u0026#34; + item); } } 注意：for-each循环不能在循环体内修改集合元素，因为它直接访问元素，而不是通过索引访问。如果需要在循环体内修改集合元素，应该使用Iterator来遍历集合，然后使用Iterator的方法来修改元素。\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); Iterator\u0026lt;Integer\u0026gt; iterator = numbers.iterator(); while (iterator.hasNext()) { Integer number = iterator.next(); if (number % 2 == 0) { iterator.remove(); // 使用Iterator的remove方法删除偶数 } } System.out.println(numbers); // 输出: [1, 3, 5] for-each循环可以遍历数组或集合的所有元素，但是不能在循环体内修改集合元素。\nint[] numbers = {1, 2, 3, 4, 5}; for (int num : numbers) { num = num * 2; // 这不会修改原数组中的元素 } System.out.println(Arrays.toString(numbers)); // 输出: [1, 2, 3, 4, 5] //正确做法是使用传统for循环修改数组 for (int i = 0; i \u0026lt; numbers.length; i++) { numbers[i] = numbers[i] * 2; // 修改原数组中的元素 } System.out.println(Arrays.toString(numbers)); // 输出: [2, 4, 6, 8, 10] 对null集合使用for-each循环时，会抛出NullPointerException异常。\nList\u0026lt;String\u0026gt; list = null; try { for (String item : list) { System.out.println(item); } } catch (NullPointerException e) { System.out.println(\u0026#34;集合为空\u0026#34;); } //正确做法是先进行null检查 if (list != null) { for (String item : list) { System.out.println(item); } } else { System.out.println(\u0026#34;集合为空\u0026#34;); } 最佳实践\n优先使用for-each循环（对于只读遍历）； 使用有意义的变量名； 处理null值； 避免复杂计算或耗时操作在循环体内； 合理选择循环类型：根据具体场景选择传统for循环或for-each循环。如果需要访问数组索引或进行复杂操作，使用传统for循环；如果只需要遍历数组或集合元素，使用for-each循环； 注意性能影响。 性能建议\n对于数组，两种循环类型的性能差异通常很小，因为数组的访问是基于索引的，而for-each循环在内部也使用了索引访问，选择for-each可读性更好一些； 对于ArrayList等随机访问集合，for循环效率高于for-each循环（性能相当），因为直接通过索引访问数组元素，无额外开销。 对于LinkedList等顺序访问集合，for-each循环通常比传统for循环快，因为for-each循环在内部使用了迭代器来遍历元素，避免内存跳跃，而传统for循环在每次迭代时都需要调用next()方法来获取下一个元素。 对于Set和其他集合，必须使用for-each循环遍历元素时，因为集合的遍历是基于迭代器的，没有索引。 避免在循环体内进行复杂的计算和对象创建。 while 语句 # while循环和do-while循环的区别\n特性 while循环 do-while循环 语法 while (循环条件) { 循环体 } do { 循环体 } while (循环条件); 循环条件判断位置 先判断循环条件，再执行循环体 先执行循环体，再判断循环条件 循环体执行次数 可能一次都不执行（如果循环条件初始为false） 至少执行一次（无论循环条件是否为true） 适用场景 当循环次数未知，仅根据循环条件判断是否继续时 当需要确保循环体至少执行一次，无论循环条件是否为true时 while循环和do-while循环都可以用于实现循环，选择使用哪种循环取决于具体场景。如果循环次数未知，或者仅根据循环条件判断是否继续，应该使用while循环。如果需要确保循环体至少执行一次，无论循环条件是否为true，应该使用do-while循环。菜单系统和用户交互通常使用do-while循环，数据处理和文件读取通常使用while循环。\n循环控制和跳转语句\nbreak语句：用于立即退出当前循环（for、while、do-while）或switch语句。 continue语句：用于跳过当前循环迭代，继续执行下一次迭代（for、while、do-while）。 return语句：用于从方法中立即返回，结束方法的执行。 break \u0026amp; continue 循环控制语句 # break语句用于立即退出当前循环（for、while、do-while）或switch语句。跳转到循环后的第一条语句；只影响最内层循环（除非使用标签）\nfor (int i = 0; i \u0026lt; 10; i++) { if (i == 5) { break; // 当i等于5时，跳出循环 } System.out.println(i); } continue语句用于跳过当前循环迭代，继续执行下一次迭代（for、while、do-while）。只影响最内层循环（除非使用标签），不能用于switch语句。\nfor (int i = 0; i \u0026lt; 10; i++) { if (i == 5) { continue; // 当i等于5时，跳过当前迭代，继续下一次迭代 } System.out.println(i); } break和continue对比\n特性 break语句 continue语句 作用 立即退出当前循环或switch语句 跳过当前迭代，继续下一次迭代 影响范围 只影响最内层循环（除非使用标签） 只影响最内层循环（除非使用标签） 适用场景 用于提前结束循环或switch语句 用于跳过当前迭代，继续下一次迭代 注意事项 不能用于switch语句 不能用于switch语句 性能影响 可以提前结束，节省时间响 跳过不必要的处理 性能优化技巧\n早期退出：在大数据集中搜索时，使用break可以显著提高性能； 跳过处理：使用continue跳过不需要的复杂计算； 条件优化：将最可能满足的条件放在前面； 循环设计：合理设计循环结构，减少不必要的迭代。 ","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base03/","section":"全部文章","summary":"","title":"Java 流程控制","type":"posts"},{"content":"Java 数组：数组基础、多维数组、数组操作。\n数组基础 # 数组的特点 # 类型统一：数组中所有的元素都是相同的数据类型。 长度固定：数组的长度在创建后不能改变。 索引访问：数组中的每个元素都有一个唯一的索引，用于访问和操作该元素。 连续存储：数组中的元素在内存中是连续存储的，每个元素的内存地址都可以通过数组的基地址和索引计算得到。 数组的声明 # 数组声明时不能指定长度，长度是在创建数组时确定的，例如int[5] arr;是错误的用法。\n数组访问越界异常 # 数组访问越界异常是指在访问数组元素时，使用了超出数组有效索引范围的索引。数组有效索引是 0～length-1，如果使用了超出这个范围的索引，就会抛出数组访问越界异常ArrayIndexOutOfBoundsException。\n数组内存模型 # // 数组内存模型 int[] arr = new int[]{10,20,30}; //栈内存：数组变量arr存储数组对象的地址； //堆内存：数组对象存储在堆内存中，每个元素占用4个字节（int类型），数组的长度是3，所以占用12个字节。 多维数组 # Java中的多维数组是指数组的数组，而不是真正的多维数组，这意味着每一行都可以有不同的长度，形成不规则数组。每一行数组可能存储在不同的位置。\n使用不规则数组时，要特别注意每一行的长度不同，避免数组越界异常，始终使用array[i].length来获取第i行的长度。\n最佳实践\n合理选择维度：根据实际需求选择合适的维度，避免过度复杂化； 初始化时指定大小：提前知道大小时，一次性分配内存； 使用增强for循环：遍历时优先使用增强for循环，简洁易读； 手动管理索引：在需要手动管理索引的情况下，使用普通for循环，避免使用增强for循环。 边界检查：访问数组元素前，进行边界检查，避免数组越界异常。 缓存数组长度：在需要多次访问数组长度的情况下，将数组长度缓存到一个变量中，避免每次都访问数组属性。 数组操作 # 包括数组复制、数组排序、数组遍历、数组搜索等操作。\n性能优化建议 # 大数组复制：使用System.arraycopy()方法复制大数组，而不是使用普通的for循环复制，因为System.arraycopy()方法是一个本地方法，执行效率更高。 Arrays.copyOf()：使用Arrays.copyOf()方法复制数组，处理常规需求，因为Arrays.copyOf()方法更简洁易读。 数组排序：使用Arrays.sort()方法对数组进行排序，而不是使用冒泡排序等简单排序算法，因为Arrays.sort()方法是一个本地方法，执行效率更高。 频繁搜索时先排序再使用二分搜索：如果需要频繁搜索数组中的元素，先对数组进行排序，然后使用二分搜索算法进行搜索，因为二分搜索算法的时间复杂度是O(log n)，而简单搜索算法的时间复杂度是O(n)。 根据数据规模选择合适算法。 数组操作的实际应用 # 学生成绩管理：复制备份数据、排序计算排名、搜索特定学生； 销售数据分析：处理销售数据、排序找出趋势、搜索异常数据； 游戏排行榜：排序玩家分数、快速查找玩家排名； 库存管理系统：排序商品、搜索特定商品、复制历史数据； 日志分析：排序日志条目、搜索错误信息、备份重要数据。 性能注意 # 大数据集操作时要特别注意算法的时间复杂度 频繁的数据操作可能会导致内存碎片，考虑使用集合类 多线程环境下要注意数组操作的线程安全性； 对于超大数据，考虑分批处理或者使用流式处理。 ","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base04/","section":"全部文章","summary":"","title":"Java 数组","type":"posts"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","section":"Tags","summary":"","title":"流程控制","type":"tags"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E7%BB%84/","section":"Tags","summary":"","title":"数组","type":"tags"},{"content":"Java 基础语法：基本数据类型、变量类型、运算符、输入输出、表达式和语句、类型转换。\nJava 基本数据类型 # java是一种强类型语言，每个变量都必须先声明后使用，且变量的类型在编译时就已经确定，不能改变。java提供了8种基本数据类型，分别是：byte、short、int、long、float、double、boolean、char。它们是java语言内置的数据类型，不是对象，直接存储在栈内存中，具有高效的存储和访问特性。\n基本数据类型的特点 # 直接存储数据值，存储在栈内存中，访问速度快。 占用内存空间大小不同，byte占用1个字节，short占用2个字节，int占用4个字节，long占用8个字节，float占用4个字节，double占用8个字节，boolean占用1个字节，char占用2个字节。都有明确取值范围。 数值类型可以进行算术运算、关系运算、逻辑运算等。 字符类型可以表示单个字符，用单引号括起来，例如：\u0026lsquo;a\u0026rsquo;、\u0026lsquo;1\u0026rsquo;、\u0026lsquo;中\u0026rsquo;等。使用Unicode编码表示字符，每个字符占用2个字节。可以使用转义字符表示一些特殊字符，例如：\u0026rsquo;\\n\u0026rsquo;表示换行符，\u0026rsquo;\\t\u0026rsquo;表示制表符等。可以进行算术运算，将字符转换为对应的整数值。 布尔类型只有两个值：true和false，用于表示逻辑判断结果。不能与其他数据类型进行转换，在jvm中实际占用的空间不止1位。 都有默认值，不需要使用new关键字创建。 金融计算建议使用BigDecimal类，避免使用float和double类型。 使用建议 # 整数类型建议使用int类型，除非有特殊需求，例如需要表示较大的整数或需要与其他语言进行交互。 浮点数类型建议使用double类型，除非有特殊需求，例如需要表示较大的浮点数或需要与其他语言进行交互。 字符类型建议使用char类型，字符串类型建议使用String类，除非有特殊需求，例如需要表示较大的字符或需要与其他语言进行交互。 布尔类型建议使用boolean类型，不要用0和1表示，除非有特殊需求，例如需要表示较大的布尔值或需要与其他语言进行交互。 不要为了节省内存而盲目使用小类型 不要在不需要时使用long或者double类型，因为它们占用的内存空间较大，访问速度较慢。 不要忘记float和long都后缀 f和l，否则会被默认解释为int类型，导致编译错误。 不要混淆char和string类型，char表示单个字符，string表示字符串。 Java 变量类型 # java变量类型分为三种：局部变量、实例变量和类变量。\n局部变量 # 局部变量是在方法、构造方法或语句块中定义的变量，它们只能在定义它们的方法、构造方法或语句块中访问。 局部变量在使用前必须先声明和初始化，否则会编译错误。 局部变量的生命周期从声明开始，到方法、构造方法或语句块结束。 局部变量存储在栈内存中，访问速度快。 实例变量 # 实例变量是在类中定义的变量，每个对象都有一个独立的实例变量副本，存储在堆内存中。 实例变量在对象创建时初始化创建，默认值为0或null，根据变量类型不同而不同。 实例变量可以在类的任何方法中访问，包括构造方法和普通方法。 实例变量的生命周期从对象创建开始，到对象销毁结束。 类变量 # 类变量是在类中使用static关键字声明的变量，所有对象共享同一个类变量副本，存储在方法区（元空间）内存中。 类变量在类加载时初始化，默认值为0或null，根据变量类型不同而不同。 类变量可以在类的任何方法中访问，可以通过类名直接访问（推荐），也可以通过对象名访问（不推荐）。包括静态方法和非静态方法。 类变量的生命周期从类加载开始，到类卸载结束。 Java 内存分配示意 # 栈内存\n存储局部变量、方法参数、返回地址等。 访问速度快，生命周期短暂。 堆内存\n存储对象实例、数组等。 访问速度较慢，生命周期较长。 方法区（元空间）内存\n存储类的结构信息、静态变量、常量池等。 访问速度较慢，生命周期较长。 Java 运算符 # java提供了丰富的运算符，用于进行各种运算操作。主要包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。\n算术运算符 # 用于进行基本的算术运算，包括加法、减法、乘法、除法和取余运算。 运算符优先级从高到低依次为：()、*、/、%、+、-。 注意：整数相除结果为整数，要得到浮点数结果，需要至少有一个操作数为浮点数。 注意：取余运算符%的结果与操作数的符号有关，例如：5%2=1，-5%2=-1，5%-2=1，-5%-2=-1。 关系运算符 # 用于比较两个值的大小关系，包括大于、小于、大于等于、小于等于。 关系运算符的结果为boolean类型，即true或false。 注意：关系运算符只能用于比较相同类型的操作数，否则会编译错误。 逻辑运算符 # 用于进行逻辑运算，包括与、或、非。 逻辑运算符的结果为boolean类型，即true或false。 注意：逻辑运算符的操作数只能为boolean类型，否则会编译错误。 注意：逻辑运算符的优先级低于关系运算符，高于位运算符。 位运算符 # 用于进行位运算，包括按位与、按位或、按位非、按位异或、左移、右移。 位运算符的操作数和结果都为整数类型，例如：int、long、byte、short。 位运算符的优先级低于算术运算符，高于赋值运算符。 注意：左移运算符\u0026laquo;将操作数的二进制位向左移动指定的位数，高位补0，低位丢弃。例如：5\u0026laquo;2=20，即00000101左移2位变为00010100，结果为20。 注意：右移运算符\u0026raquo;将操作数的二进制位向右移动指定的位数，高位补符号位（正数补0，负数补1），低位丢弃。例如：-5\u0026raquo;2=-2，即11111011右移2位变为11111110，结果为-2。 字符串比较注意：\n== 比较的是引用（内存地址），不是内容；equals()方法比较的是内容。使用compareTo()方法可以比较字符串的内容。字符串比较使用equals()方法，而不是==运算符。\n短路求值机制\n逻辑与（\u0026amp;\u0026amp;）：如果左操作数为false，右操作数不会被求值，直接返回false。 逻辑或（||）：如果左操作数为true，右操作数不会被求值，直接返回true。 可以提高程序性能，避免不必要的计算。\nJava 输入和输出 # Scanner方法详解\nScanner类是java.util包中的一个类，用于从输入流中读取数据。常用于从控制台读取用户输入的数据。\nScanner类的常用方法 next()：读取一个字符串，遇到空格、制表符或换行符结束。 nextInt()：读取一个整数，遇到空格、制表符或换行符结束。 nextDouble()：读取一个浮点数，遇到空格、制表符或换行符结束。 nextLine()：读取一行字符串，包括空格、制表符和换行符。 hasNext()：判断是否还有下一个输入项。 hasNextInt()：判断是否还有下一个整数输入项。 hasNextDouble()：判断是否还有下一个浮点数输入项。 使用nextInt()方法后，如果要使用nextLine()方法，需要在nextInt()方法后调用一次nextLine()方法，将换行符消耗掉。 Scanner使用完毕之后，应该调用close()方法关闭Scanner对象，释放资源。 使用try-catch语句来处理Scanner类可能抛出的异常，例如：InputMismatchException、NoSuchElementException等。\nJava 类型转换 # 类型转换分类：\n自动类型转换（隐式转换）：由编译器自动完成；（由小范围向大范围转换） 强制类型转换（显式转换）：需要程序员明确指定。（由大范围向小范围转换） 包装类转换：基本类型与包装类之间的转换（性能开销大） 字符串转换：字符串与其他类型之间的转换 由小到大： char-byte-short-int-long-float-double\n由小到大的转换：可以存在精度丢失，例如：将int类型转换为float类型时，可能会丢失小数部分。 由大到小的转换：可能会数据溢出，例如：将long类型转换为int类型时，可能会丢失高位数据。 ","date":"2021年1月8日","externalUrl":null,"permalink":"/posts/java-base02/","section":"全部文章","summary":"","title":"Java 基础语法","type":"posts"},{"content":"","date":"2021年1月8日","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","section":"Tags","summary":"","title":"基础语法","type":"tags"},{"content":"Java 入门基础：Java 简介，JDK、JRE、JVM、Hello World 程序。\n1. Java 简介 # 1.1 简述Java语言的主要特性 # Java 是一种面向对象的编程语言，具有封装、多态、继承的基础特性，同时也具有以下主要特性：\n平台独立性：Java 程序编译后生成字节码，在任何安装了 Java 运行环境（JRE）的平台上都可以运行。 自动内存管理：Java 虚拟机（JVM）负责管理内存，开发人员无需手动分配和释放内存。 异常处理：Java 提供了强大的异常处理机制，使程序能够处理运行时错误。 多线程支持：Java 支持多线程编程，允许程序并发执行多个任务。 丰富的类库：Java 提供了丰富的类库，开发人员可以利用这些类库快速开发应用程序。 1.2 解释Java程序的编译和运行过程 # Java 程序的编译和运行过程包括以下几个步骤：\n编写源代码：使用文本编辑器或集成开发环境（IDE）编写 Java 源代码文件（.java 文件）。 编译源代码：使用 Java 编译器（javac）将源代码编译为字节码文件（.class 文件）。 运行字节码：使用 Java 虚拟机（JVM）运行编译后的字节码文件。 加载类：JVM 加载字节码文件，并在内存中创建类的实例。 执行程序：JVM 执行字节码指令，完成程序的运行。 垃圾回收：JVM 自动管理内存，回收不再使用的对象占用的内存空间。 结束程序：程序执行完毕后，JVM 结束程序的运行。 输出结果：程序的输出结果显示在控制台或指定的输出设备上。 一张图先印在脑子里\n源码 Hello.java →【javac 编译】→ 字节码 Hello.class →【java 运行】→ 机器码（JIT 后） 三句话记住核心\njavac 只做一件事：把 .java 人类源码翻译成 .class 字节码（中立、跨平台）。 java 启动 JVM → 加载 .class → 字节码校验 → 解释执行 + 热点代码 JIT 成本地机器码。 不同操作系统装不同的 JVM，所以同一份 .class 文件能在 Windows/Mac/Linux 上跑，即“一次编译，到处运行”。 十行命令全程肉眼可见\n# 1. 写源码 cat \u0026gt; Hello.java \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; public class Hello { public static void main(String[] args) { System.out.println(\u0026#34;compile once, run anywhere\u0026#34;); } } EOF # 2. 编译：源码→字节码 javac Hello.java # 生成 Hello.class（二进制，可用 hexdump 看） # 3. 运行：JVM 装载并执行 java Hello # 注意后面不带 .class 输出：\ncompile once, run anywhere 细节放大镜（面试常问）\n阶段 关键文件/组件 做了什么 编译期 javac 词法分析 → 语法树 → 语义分析 → 生成字节码指令 类装载 ClassLoader 加载 .class → 创建 Class 对象 → 方法区/元空间存类型信息 字节码校验 Bytecode Verifier 检查跳转到非法地址、操作数栈溢出等，防止恶意代码 执行引擎 解释器 + JIT (HotSpot C1/C2) 先解释执行，热点代码（默认 1 万次调用）编译成本地机器码并缓存 垃圾回收 GC 线程 回收堆上不再可达的对象，让程序员不用手动 free 动手验证 JIT 的存在\njava -XX:+PrintCompilation Hello 能看到类似：\n87 1 3 java.lang.String::hashCode (56 bytes) 即热点方法被即时编译成高效机器码。\n常见误区提醒\n误区 1：Java 是“纯解释”执行。\n→ 错！热点代码会被 JIT 编译，速度与 C++ 接近。 误区 2：javac 把代码直接编译成机器码。\n→ 错！javac 只到字节码，机器码是 JVM 运行时按需生成的。 误区 3：运行时必须带着源码 .java。\n→ 错！只需要 .class 或打包后的 .jar。 一张命令速查表（保存备用）\n任务 命令 编译单个文件 javac Hello.java 编译并指定输出目录 javac -d out Hello.java 运行类 java -cp out Hello 打包 jar cf hello.jar -C out . 运行 jar java -jar hello.jar （需 jar 内指定 Main-Class） 查看字节码 javap -c Hello 查看 JIT 编译 java -XX:+PrintCompilation Hello 1.3 比较 Java 与 C++ 的主要区别 # 特性 Java C++ 内存管理 自动垃圾回收（JVM 管理内存） 手动内存管理（需 malloc/free） 平台依赖性 跨平台（一次编译，到处运行） 平台相关（需针对不同平台编译） 编译方式 编译成字节码，由 JVM 解释执行或 JIT 编译成本地机器码 编译成本地机器码 指针支持 不支持指针，使用引用 支持指针操作 多继承 不支持类的多继承，支持接口多继承 支持类的多继承 运行时性能 较高（JIT 优化） 通常较高（直接机器码执行） 标准库 丰富的标准类库 丰富的标准模板库（STL） 异常处理 强制异常处理机制 可选异常处理机制 多线程支持 内置多线程支持 通过库支持多线程 编译器 javac g++, clang++ 内存管理：有没有“垃圾回收”\n维度 Java C++ 谁来回收 自动 GC（Garbage Collector） 程序员自己 new/delete 或智能指针 写代码感觉 只管 new，不管 free 必须配对，否则内存泄漏/悬空指针 运行代价 停顿式 GC 带来微小延迟 无 GC 停顿，但可能野指针崩溃 一句话总结：\nJava 像“保洁阿姨每天帮你倒垃圾”；C++ 像“自己做饭自己洗碗，洗不干净就招蟑螂”。\n面向对象模型：有没有“真正的类”\n维度 Java C++ 基本类型 int/boolean/char 不是对象 int/bool/char 就是普通内存值 多态机制 默认虚方法（virtual） 需手动加 virtual，否则静态绑定 多重继承 类只能单继承，接口可多继承 类可多继承，带来菱形问题（需 virtual 基类） 运行时类型 反射随时拿到 Class\u0026lt;?\u0026gt; 只有虚表，RTTI 有限且需开启编译器选项 一句话总结：\nJava 把“面向对象”写进 DNA，连数组都是对象；C++ 既能面向对象也能面向过程，还能面向汇编。\n跨平台方式：编译一次 vs 每个平台编一次\n维度 Java C++ 产出文件 .class 字节码 机器码可执行文件/动态库 运行依赖 目标机器装对应 JVM 目标机器无需额外运行时，但可能要装 VC++ redist 性能 先解释后 JIT，峰值≈C++ 90% 编译期极致优化，可内联汇编 移植成本 最低，同一份 jar 到处跑 需重新编译，宏/条件编译处理平台差异 一句话总结：\nJava 带着“翻译机（JVM）”出差；C++ 提前把当地话说好，换城市就重学方言。\n2 个常考差异（面试加料）\n指针 vs 引用\nC++ 有指针运算、int* p++ 可以直接窜内存；Java 只有“安全引用”，不能做任何地址运算，杜绝野指针。\n异常机制\nJava 必检异常（checked exception）强迫方法签名声明；C++ 异常任意抛，不声明也能编译通过。\n2. Java 开发环境 # JDK（Java Development Kit） 是 Java 开发的基础工具包，包含了编译、调试、运行等必要的工具。(包含javac、java、javadoc、jar、jdb、javap-反编译器显示class文件) JRE（Java Runtime Environment） 是 Java 运行时环境，包含了 JVM 和 Java 标准类库。 JVM（Java Virtual Machine） 是 Java 虚拟机，负责执行 Java 字节码，实现跨平台运行。（字节码执行、内存管理、垃圾回收、安全管理、异常处理） IDEA（IntelliJ IDEA） 是 Java 开发的集成开发环境（IDE），提供了代码编辑、调试、构建等功能。 3. JVM内存结构 # JVM 内存结构主要包括以下几个部分：\n方法区（Method Area）：存储类信息、静态变量、常量池等。 堆内存（Heap）：存储对象实例和数组，是垃圾回收的主要区域。 栈内存（Stack）：存储方法调用、局部变量等。 本地方法栈（Native Method Stack）：存储本地方法调用。 程序计数器（Program Counter Register）：记录当前线程执行的字节码指令地址。 为什么需要jvm：实现跨平台运行、自动内存管理、提供安全沙箱、优化程序执行、统一的异常处理机制。\n","date":"2021年1月8日","externalUrl":null,"permalink":"/posts/java-base01/","section":"全部文章","summary":"","title":"Java 入门基础","type":"posts"},{"content":"","date":"2021年1月8日","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/","section":"Tags","summary":"","title":"基础环境","type":"tags"},{"content":"学习Java之前，先要学习基础环境搭建，包括安装JDK、配置环境变量、安装IDE等；还要掌握Maven的使用，包括安装Maven、配置环境变量、创建Maven项目等;最后要掌握Java的专业开发工具IntelliJ IDEA等。\n1. 一键安装 JDK 17（LTS） # # 0. 先装 Homebrew（若已装可跳过） /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # 1. 用 brew 装 JDK 17（自动配好环境变量） brew install openjdk@17 # 2. 让系统认出 java（一次性） echo \u0026#39;export PATH=\u0026#34;/opt/homebrew/opt/openjdk@17/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc # 3. 验证 java -version # 应显示 openjdk 17.0.x javac -version # 同上 若出现版本号即成功；未出现请重启终端再试 。\n2. 一键安装 Maven（Java 依赖管理神器） # brew install maven # 验证 mvn -v # 能看到 Apache Maven 3.9.x 与 JDK 17 路径 Maven 默认仓库在国外，第一次下载依赖较慢，可换阿里云镜像（可选）：\nmkdir -p ~/.m2 cat \u0026gt; ~/.m2/settings.xml \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026lt;settings\u0026gt; \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;aliyunmaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Aliyun Maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;/settings\u0026gt; EOF 3. 一键安装 IntelliJ IDEA # 社区版免费，最好不要用社区版，后续上SpringBoot等框架时会遇到问题\nbrew install --cask intellij-idea-ce 装完在“启动台”里会出现 IntelliJ IDEA CE，首次打开按提示：\n主题/插件页一路 Skip All and Set Defaults 新建项目 → 左侧选 Maven → 右侧 SDK 选 openjdk-17 → Finish 在 src/main/java 右键 → New Java Class → 输入 Hello → 写 main 方法： public class Hello { public static void main(String[] args) { System.out.println(\u0026#34;Hello, Java on Mac!\u0026#34;); } } 点击绿色 ▶️ 运行，控制台打印即环境 100 % OK 。\n常用快捷键（先记 3 个） # 功能 快捷键 运行 Control + R 格式化代码 Command + Option + L 全局搜索类 双击 Shift 4. 一键安装 MySQL 8.0 # brew install mysql@8.0 安装完会提示它不在默认 PATH，我们顺手配好：\necho \u0026#39;export PATH=\u0026#34;/opt/homebrew/opt/mysql@8.0/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc # 第一次启动 brew services start mysql@8.0 # 按提示设 root 密码、删除匿名用户、禁止远程 root 登录等 mysql_secure_installation 全部选 y 即可，密码记好 。\n验证 MySQL 是否安装成功：\nmysql -uroot -p 输入刚才的密码，看到 mysql\u0026gt; 提示符后执行：\nCREATE DATABASE demo CHARACTER SET utf8mb4; exit 能正常进入即安装成功 。\n让 MySQL 开机自启（可选）\nbrew services start mysql@8.0 # 已经自带开机自启 以后想停/重启：\nbrew services stop mysql@8.0 brew services restart mysql@8.0 5. 目录速查（记不住就回来翻） # 工具 安装路径 配置文件 JDK /opt/homebrew/opt/openjdk@17 ~/.zshrc Maven /opt/homebrew/opt/maven ~/.m2/settings.xml IDEA /Applications/IntelliJ IDEA CE.app ~/Library/Preferences/IdeaIC2025.x ","date":"2021年1月8日","externalUrl":null,"permalink":"/posts/java-env-base/","section":"全部文章","summary":"","title":"基础环境搭建","type":"posts"},{"content":"","date":"2021年1月8日","externalUrl":null,"permalink":"/tags/%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"入门基础","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/juc/","section":"Categories","summary":"","title":"JUC","type":"categories"},{"content":"","externalUrl":null,"permalink":"/categories/jvm/","section":"Categories","summary":"","title":"JVM","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"欢迎你来到我的个人博客！\n我是 Holly，一个还在起步路上的技术小白。\n现在的我，正埋头啃着 Java 和 MySQL 的基础语法，一遍遍调试代码，一次次理解数据表之间的关系。我知道自己还很“菜”，但我不怕承认——因为每个大神都曾是从第一行 “Hello, World!” 开始的。\n我选择用这个博客记录下学习中的每一个脚印：可能是某个让我卡住三天的 Bug，也可能是一段终于跑通的脚本；是读书笔记，也是实战心得。我不追求高深，只想真实地留下自己成长的痕迹。\n我希望自己能一步步走向更广阔的领域：分布式系统、中间件、云计算、大模型……这些领域我都想探索，我愿意用时间和努力去靠近它们，也愿意和其他的人分享我的经验和发现。\n我相信：保持天真，才能对未知保持好奇；保持烂漫，才能在枯燥的代码中找到乐趣；保持纯粹，才能在复杂的系统中找到简单的解决方案。\n这里也会分享我放在 GitHub 和 Gitee 上的项目——也许它们现在还很稚嫩，但每一个都是我思考与尝试的结晶。\n如果你也正在学习路上，欢迎你常来看看。我们可以一起交流，彼此鼓励。\n永远天真，永远烂漫，永远纯粹，永远在路上。\n联系方式 # GitHub: github.com/hollyblog/ Gitee: gitee.com/hollyblog/ Email: 2285549633@qq.com ","externalUrl":null,"permalink":"/about/","section":"关于我","summary":"","title":"关于我","type":"about"},{"content":"","externalUrl":null,"permalink":"/categories/framework/","section":"Categories","summary":"","title":"框架应用","type":"categories"},{"content":"","externalUrl":null,"permalink":"/categories/sa/","section":"Categories","summary":"","title":"系统架构","type":"categories"},{"content":"","externalUrl":null,"permalink":"/categories/threadpool/","section":"Categories","summary":"","title":"线程池","type":"categories"},{"content":"","externalUrl":null,"permalink":"/categories/ops/","section":"Categories","summary":"","title":"运维部署","type":"categories"}]