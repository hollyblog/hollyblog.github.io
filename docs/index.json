
[{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/categories/resume/","section":"Categories","summary":"","title":"Resume","type":"categories"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/resume/","section":"Tags","summary":"","title":"Resume","type":"tags"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 👧Holly 求职意向：后端开发工程师 工作经验：三年（含个人项目实战） 电话：131****6107 出生年月：1996年08月 邮箱：2285549633@qq.com 🚀教育及工作经历 # 2015.09 - 2019.07 山东建筑大学 软件工程 本科 2019.09 - 2022.07 大连理工大学 软件工程 硕士 2022.07 - 2023.04 北京金山云 公有云 后端工程师 2023.05 - 2025.11 个人创业项目 餐饮业务 全栈工程师 🔨专业技能 # 大模型应用开发：掌握LangChain4J框架，具备构建RAG系统、Agents的实战经验；熟悉提示工程原则，了解大模型微调方法；具备本地部署开源大模型的能力；了解向量数据库的原理与应用。 后端开发：熟练使用SpringBoot、SpringCloud微服务架构及其常用组件，熟悉服务网格、分布式事务、配置管理；熟悉MySQL（索引、事务、分库分表、读写分离）、Redis（数据结构、分布式锁）、RabbitMQ（消息可靠性保证、顺序性保障机制）等中间件的原理与应用。 部署与运维：掌握Docker技术，了解Kubernetes基础；拥有使用Jenkins实施CI/CD的经验；了解监控告警技术（ Prometheus + Grafana）。 编程基础：掌握JVM的内存分析、垃圾回收机制、GC调优、性能监控；掌握多线程并发编程、常用数据结构和算法及设计模式；熟悉网络基础（TCP/IP, HTTP/HTTPS）。 💻项目经历 # 一、智能餐饮推荐与服务系统个人开发项目2023.04 - 至今 项目描述：整合外卖与点评业务，基于大语言模型构建智能餐饮平台，实现智能推荐、客服自动化和评价分析三大模块，新用户首单转化率提升18%，客服人工干预率下降70%，用户投诉响应时效缩短至10分钟内。\n使用技术：\n后端框架：SpringBoot + MySQL + MongoDB + Redis + RabbitMQ AI框架：LangChain4J + Qwen-1.8B + Chroma + 通义千问 API 部署与运维：Docker + Nginx 工作亮点：\n智能推荐模块：基于LangChain4J设计用户行为-菜品特征双向量模型，复购率提升25%；实现基于地域特征的冷启动方案，新用户首单转化率提高18%。 智能客服模块：调用通义千问API实现常见问题自动应答（如 “退款流程”“配送范围”），设计并优化了多轮对话的Prompt，客服人工干预率降低70%。 智能评价模块：使用本地部署大模型支撑评价情感分析，提取 “菜品不新鲜”“配送超时” 等关键词，推送商家告警，用户投诉响应时效从2小时缩至10分钟。 高并发架构优化：对Qwen-1.8B采用4-bit量化部署，显存占用从8GB降至2.5GB，推理响应时间从800ms优化至400ms，支撑高峰期每秒30+大模型请求稳定处理；基于Sharding-JDBC对订单表水平分片，查询性能提升40%；设计Redis分布式锁 + RabbitMQ异步通信架构，订单创建耗时从500ms降至150ms。 二、分布式云监控与智能运维平台个人开发项目2024.04 - 至今 项目描述：一站式云资源监控与运维平台，构建RAG运维知识库，解决分布式环境下运维效率低下的问题。可同时监控300+节点，故障处理效率提升40%，服务可用性达99.9%。\n使用技术：\n后端框架：SpringBoot + SpringCloud + MySQL + Redis + Netty + Prometheus + Grafana 消息队列：RabbitMQ（日志处理） + Pulsar（实时监控指标） 日志系统：ELK（Elasticsearch + Logstash + Kibana） AI框架：LangChain4J + Qwen-7B-Chat + Milvus + Sentence-BERT 权限控制：JWT + HTTPS 工作亮点：\n智能运维助手：构建基于RAG的智能问答系统，将运维手册、故障案例文档按512-token粒度切片，使用sentence-transformers生成768维向量存入Milvus数据库；基于LangChain4J集成本地部署的Qwen-7B-Chat大模型，实现语义检索与生成；支持自然语言提问，检索准确率达85%，故障处理效率提升40%。 监控告警与日志系统：基于Prometheus自定义Exporter采集服务器基础指标，配合Grafana构建多维度监控大盘，支持自定义告警规则；设置分级告警机制；通过Logback AsyncAppender异步发送日志到RabbitMQ，使用Logstash解析并写入Elasticsearch，实现日志快速检索，问题定位效率提升60%以上。 系统安全与优化：基于Netty自定义协议实现高性能数据接收端，支持百万级并发连接；结合Pulsar消息队列实现削峰填谷，应对海量监控指标上报；使用Redis缓存热点监控数据，LRU淘汰策略保证稳定运行；实现基于JWT的RBAC权限控制与HTTPS双向认证；设计统一错误码规范与结构化日志格式，便于后期排查问题。 👩‍💻自我评价 # 技术复合能力：具备扎实的后端开发功底与系统架构思维，并对大模型应用开发有浓厚的兴趣和项目实践，善于将工程化思维应用于AI场景。 持续学习能力：学习与适应能力强，能够快速钻研并掌握新技术，并成功将其落地于项目中（如智能餐饮系统、运维问答助手）。 团队协作能力：做事认真踏实，有责任心，具备良好的团队协作精神和沟通能力，渴望在优秀的业务团队中贡献技术力量并快速成长。 ","date":"2025年11月24日","externalUrl":null,"permalink":"/resume/","section":"个人简历","summary":"","title":"个人简历","type":"resume"},{"content":"专注于分布式系统设计、中间件性能优化、云计算和大模型应用相关领域的学习和分享。 ","date":"2025年11月24日","externalUrl":null,"permalink":"/","section":"永远天真烂漫","summary":"","title":"永远天真烂漫","type":"page"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/categories/database-interview/","section":"Categories","summary":"","title":"Database-Interview","type":"categories"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/mysql/","section":"Tags","summary":"","title":"MySQL","type":"tags"},{"content":" 引言 # 在这里写文章的引言内容\u0026hellip;\n正文 # 在这里写文章的主要内容\u0026hellip;\n总结 # 在这里写文章的总结\u0026hellip;\n","date":"2025年11月24日","externalUrl":null,"permalink":"/posts/mysql-first/","section":"全部文章","summary":"","title":"MySQL 基础 - 01","type":"posts"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/posts/","section":"全部文章","summary":"","title":"全部文章","type":"posts"},{"content":"","date":"2025年11月24日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"Tags","summary":"","title":"数据库","type":"tags"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/categories/distributed/","section":"Categories","summary":"","title":"Distributed","type":"categories"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统","type":"tags"},{"content":"分布式系统是现代软件架构的重要组成部分，本文将介绍分布式系统设计的核心原则和实践方法。\nCAP 理论 # CAP 理论是分布式系统设计的基础理论之一，它指出分布式系统无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）三个特性。\n在实际应用中，由于网络分区是不可避免的，系统设计者必须在一致性和可用性之间做出权衡。不同的应用场景需要不同的选择策略。\n例如，金融系统通常选择强一致性，而社交网络则可以接受最终一致性以获得更好的可用性。\n一致性模型 # 在分布式系统中，一致性是一个关键问题。常见的一致性模型包括强一致性、最终一致性、因果一致性等。\n强一致性保证所有节点在任何时刻看到的数据都是一致的，但会牺牲系统的可用性和性能。最终一致性则允许短时间的不一致，但保证最终会达到一致状态。\n选择合适的一致性模型需要根据业务需求、性能要求和系统复杂度来综合考虑。\n分布式事务 # 分布式事务是分布式系统中的难题之一。传统的两阶段提交（2PC）协议虽然能保证事务的ACID特性，但存在性能问题和单点故障风险。\n现代分布式系统通常采用补偿事务（Saga）、TCC（Try-Confirm-Cancel）等柔性事务方案，在保证业务最终一致性的同时，获得更好的性能和可用性。\n总结 # 分布式系统设计需要在一致性、可用性和分区容错性之间做出权衡。理解CAP理论、掌握各种一致性模型和事务处理方案，是构建高质量分布式系统的基础。\n","date":"2025年1月20日","externalUrl":null,"permalink":"/posts/distributed-system-design/","section":"全部文章","summary":"","title":"分布式系统设计实践","type":"posts"},{"content":"","date":"2025年1月20日","externalUrl":null,"permalink":"/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"架构设计","type":"tags"},{"content":"","date":"2025年1月18日","externalUrl":null,"permalink":"/categories/cloud/","section":"Categories","summary":"","title":"Cloud","type":"categories"},{"content":"","date":"2025年1月18日","externalUrl":null,"permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"Kubernetes","type":"tags"},{"content":"","date":"2025年1月18日","externalUrl":null,"permalink":"/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/","section":"Tags","summary":"","title":"云计算","type":"tags"},{"content":"","date":"2025年1月18日","externalUrl":null,"permalink":"/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/","section":"Tags","summary":"","title":"云原生","type":"tags"},{"content":"云原生架构是云计算时代的重要技术趋势，本文将介绍云原生架构的核心概念和演进过程。\n什么是云原生 # 云原生是一种构建和运行应用程序的方法，充分利用云计算的优势。云原生应用程序设计用于在云平台上运行，具有高可用性、可扩展性和弹性。\n云原生的核心理念包括：微服务架构、容器化、持续集成/持续部署（CI/CD）、DevOps文化等。这些理念共同构成了现代应用开发的最佳实践。\n容器化技术 # Docker 和 Kubernetes 是云原生的核心技术。Docker 提供了应用程序的打包和隔离机制，而 Kubernetes 则提供了容器编排和管理能力。\n通过容器技术，开发者可以将应用程序及其依赖打包成一个独立的单元，确保在不同环境中的一致性。Kubernetes 则负责自动化部署、扩展和管理这些容器化应用。\n容器化带来的优势包括：快速部署、环境一致性、资源高效利用、易于扩展等。这些特性使得容器成为云原生应用的基础设施。\n微服务架构 # 微服务是云原生架构的重要组成部分。相比传统的单体应用，微服务将应用拆分为多个独立的小服务，每个服务负责特定的业务功能。\n微服务架构的优势包括：独立部署、技术栈灵活、故障隔离、团队自治等。但同时也带来了分布式系统的复杂性，需要处理服务发现、负载均衡、熔断降级等问题。\n总结 # 云原生架构代表了应用开发和部署的未来方向。通过采用云原生技术和实践，企业可以构建更加灵活、可靠和高效的应用系统。\n","date":"2025年1月18日","externalUrl":null,"permalink":"/posts/cloud-native-architecture/","section":"全部文章","summary":"","title":"云原生架构演进","type":"posts"},{"content":"","date":"2025年1月15日","externalUrl":null,"permalink":"/tags/ai/","section":"Tags","summary":"","title":"AI","type":"tags"},{"content":"","date":"2025年1月15日","externalUrl":null,"permalink":"/categories/llm/","section":"Categories","summary":"","title":"LLM","type":"categories"},{"content":"","date":"2025年1月15日","externalUrl":null,"permalink":"/tags/llm/","section":"Tags","summary":"","title":"LLM","type":"tags"},{"content":"","date":"2025年1月15日","externalUrl":null,"permalink":"/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/","section":"Tags","summary":"","title":"大模型","type":"tags"},{"content":"大语言模型（LLM）正在改变软件开发的方式，本文将介绍如何开发基于大模型的应用，以及相关的最佳实践。\n大模型基础 # 大语言模型是基于Transformer架构的深度学习模型，通过在海量文本数据上预训练，获得了强大的自然语言理解和生成能力。\n当前主流的大模型包括GPT系列、Claude、文心一言等。这些模型可以完成文本生成、问答、翻译、代码生成等多种任务。\n理解大模型的能力边界和局限性是开发应用的前提。大模型虽然强大，但也存在幻觉、知识过时、推理能力有限等问题。\nPrompt Engineering # Prompt Engineering（提示词工程）是使用大模型的关键技能。一个好的提示词可以显著提升模型的输出质量。\n设计提示词的技巧包括：明确任务目标、提供示例（Few-shot Learning）、分步骤引导、使用思维链（Chain of Thought）等方法。\n此外，还需要注意提示词的长度控制、上下文管理、输出格式约束等细节问题。\n实战案例 # 构建一个智能问答系统需要考虑多个方面：知识库构建、向量检索、提示词设计、结果验证等。\n首先需要准备领域知识，将其转换为向量存储。当用户提问时，通过语义检索找到相关知识，组合成上下文，然后让大模型基于这些信息回答问题。\n这种RAG（检索增强生成）模式可以有效减少模型幻觉，提供更准确和可靠的答案。\n总结 # 大模型应用开发需要深入理解模型能力、掌握提示词工程技巧、合理设计系统架构。随着技术的发展，大模型将在更多领域发挥重要作用。\n","date":"2025年1月15日","externalUrl":null,"permalink":"/posts/llm-application-development/","section":"全部文章","summary":"","title":"大模型应用开发实战","type":"posts"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/categories/middleware-interview/","section":"Categories","summary":"","title":"Middleware-Interview","type":"categories"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/rabbitmq/","section":"Tags","summary":"","title":"Rabbitmq","type":"tags"},{"content":"Redis 是最常用的缓存中间件之一，本文将分享 Redis 性能优化的实践经验。\n数据结构选择 # 选择合适的数据结构对性能至关重要\u0026hellip;\n持久化策略 # 合理配置 RDB 和 AOF\u0026hellip;\n集群方案 # Redis Cluster 和哨兵模式\u0026hellip;\n","date":"2025年1月12日","externalUrl":null,"permalink":"/posts/rabbitmq-performance-optimization/","section":"全部文章","summary":"","title":"RabbitMQ 性能优化实践","type":"posts"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/redis/","section":"Tags","summary":"","title":"Redis","type":"tags"},{"content":"Redis 是最常用的缓存中间件之一，本文将分享 Redis 性能优化的实践经验。\n数据结构选择 # 选择合适的数据结构对性能至关重要\u0026hellip;\n持久化策略 # 合理配置 RDB 和 AOF\u0026hellip;\n集群方案 # Redis Cluster 和哨兵模式\u0026hellip;\n","date":"2025年1月12日","externalUrl":null,"permalink":"/posts/redis-performance-optimization/","section":"全部文章","summary":"","title":"Redis 性能优化实践","type":"posts"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","section":"Tags","summary":"","title":"性能优化","type":"tags"},{"content":"","date":"2025年1月12日","externalUrl":null,"permalink":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/","section":"Tags","summary":"","title":"中间件","type":"tags"},{"content":"索引是数据库性能优化的关键，本文将介绍 MySQL 索引优化的方法。\n索引类型 # B+树索引、哈希索引、全文索引\u0026hellip;\n索引设计原则 # 如何设计高效的索引\u0026hellip;\n慢查询优化 # 使用 EXPLAIN 分析查询性能\u0026hellip;\n","date":"2025年1月10日","externalUrl":null,"permalink":"/posts/mysql-index-optimization/","section":"全部文章","summary":"","title":"MySQL 索引优化指南","type":"posts"},{"content":"","date":"2025年1月10日","externalUrl":null,"permalink":"/tags/%E7%B4%A2%E5%BC%95/","section":"Tags","summary":"","title":"索引","type":"tags"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"Java 流程控制：if-else、switch、循环（for、while、do-while）、跳转语句（break、continue、return）。\nif-else # 在这里写文章的引言内容\u0026hellip;\n正文 # 在这里写文章的主要内容\u0026hellip;\n总结 # 在这里写文章的总结\u0026hellip;\n","date":"2021年1月9日","externalUrl":null,"permalink":"/posts/java-base03/","section":"全部文章","summary":"","title":"Java 流程控制","type":"posts"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/categories/java-base/","section":"Categories","summary":"","title":"Java-Base","type":"categories"},{"content":"","date":"2021年1月9日","externalUrl":null,"permalink":"/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","section":"Tags","summary":"","title":"流程控制","type":"tags"},{"content":"Java 基础语法：基本数据类型、变量类型、运算符、输入输出、表达式和语句、类型转换。\nJava 基本数据类型 # java是一种强类型语言，每个变量都必须先声明后使用，且变量的类型在编译时就已经确定，不能改变。java提供了8种基本数据类型，分别是：byte、short、int、long、float、double、boolean、char。它们是java语言内置的数据类型，不是对象，直接存储在栈内存中，具有高效的存储和访问特性。\n基本数据类型的特点 # 直接存储数据值，存储在栈内存中，访问速度快。 占用内存空间大小不同，byte占用1个字节，short占用2个字节，int占用4个字节，long占用8个字节，float占用4个字节，double占用8个字节，boolean占用1个字节，char占用2个字节。都有明确取值范围。 数值类型可以进行算术运算、关系运算、逻辑运算等。 字符类型可以表示单个字符，用单引号括起来，例如：\u0026lsquo;a\u0026rsquo;、\u0026lsquo;1\u0026rsquo;、\u0026lsquo;中\u0026rsquo;等。使用Unicode编码表示字符，每个字符占用2个字节。可以使用转义字符表示一些特殊字符，例如：\u0026rsquo;\\n\u0026rsquo;表示换行符，\u0026rsquo;\\t\u0026rsquo;表示制表符等。可以进行算术运算，将字符转换为对应的整数值。 布尔类型只有两个值：true和false，用于表示逻辑判断结果。不能与其他数据类型进行转换，在jvm中实际占用的空间不止1位。 都有默认值，不需要使用new关键字创建。 金融计算建议使用BigDecimal类，避免使用float和double类型。 使用建议 # 整数类型建议使用int类型，除非有特殊需求，例如需要表示较大的整数或需要与其他语言进行交互。 浮点数类型建议使用double类型，除非有特殊需求，例如需要表示较大的浮点数或需要与其他语言进行交互。 字符类型建议使用char类型，字符串类型建议使用String类，除非有特殊需求，例如需要表示较大的字符或需要与其他语言进行交互。 布尔类型建议使用boolean类型，不要用0和1表示，除非有特殊需求，例如需要表示较大的布尔值或需要与其他语言进行交互。 不要为了节省内存而盲目使用小类型 不要在不需要时使用long或者double类型，因为它们占用的内存空间较大，访问速度较慢。 不要忘记float和long都后缀 f和l，否则会被默认解释为int类型，导致编译错误。 不要混淆char和string类型，char表示单个字符，string表示字符串。 Java 变量类型 # java变量类型分为三种：局部变量、实例变量和类变量。\n局部变量 # 局部变量是在方法、构造方法或语句块中定义的变量，它们只能在定义它们的方法、构造方法或语句块中访问。 局部变量在使用前必须先声明和初始化，否则会编译错误。 局部变量的生命周期从声明开始，到方法、构造方法或语句块结束。 局部变量存储在栈内存中，访问速度快。 实例变量 # 实例变量是在类中定义的变量，每个对象都有一个独立的实例变量副本，存储在堆内存中。 实例变量在对象创建时初始化创建，默认值为0或null，根据变量类型不同而不同。 实例变量可以在类的任何方法中访问，包括构造方法和普通方法。 实例变量的生命周期从对象创建开始，到对象销毁结束。 类变量 # 类变量是在类中使用static关键字声明的变量，所有对象共享同一个类变量副本，存储在方法区（元空间）内存中。 类变量在类加载时初始化，默认值为0或null，根据变量类型不同而不同。 类变量可以在类的任何方法中访问，可以通过类名直接访问（推荐），也可以通过对象名访问（不推荐）。包括静态方法和非静态方法。 类变量的生命周期从类加载开始，到类卸载结束。 Java 内存分配示意 # 栈内存\n存储局部变量、方法参数、返回地址等。 访问速度快，生命周期短暂。 堆内存\n存储对象实例、数组等。 访问速度较慢，生命周期较长。 方法区（元空间）内存\n存储类的结构信息、静态变量、常量池等。 访问速度较慢，生命周期较长。 Java 运算符 # java提供了丰富的运算符，用于进行各种运算操作。主要包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。\n算术运算符 # 用于进行基本的算术运算，包括加法、减法、乘法、除法和取余运算。 运算符优先级从高到低依次为：()、*、/、%、+、-。 注意：整数相除结果为整数，要得到浮点数结果，需要至少有一个操作数为浮点数。 注意：取余运算符%的结果与操作数的符号有关，例如：5%2=1，-5%2=-1，5%-2=1，-5%-2=-1。 关系运算符 # 用于比较两个值的大小关系，包括大于、小于、大于等于、小于等于。 关系运算符的结果为boolean类型，即true或false。 注意：关系运算符只能用于比较相同类型的操作数，否则会编译错误。 逻辑运算符 # 用于进行逻辑运算，包括与、或、非。 逻辑运算符的结果为boolean类型，即true或false。 注意：逻辑运算符的操作数只能为boolean类型，否则会编译错误。 注意：逻辑运算符的优先级低于关系运算符，高于位运算符。 位运算符 # 用于进行位运算，包括按位与、按位或、按位非、按位异或、左移、右移。 位运算符的操作数和结果都为整数类型，例如：int、long、byte、short。 位运算符的优先级低于算术运算符，高于赋值运算符。 注意：左移运算符\u0026laquo;将操作数的二进制位向左移动指定的位数，高位补0，低位丢弃。例如：5\u0026laquo;2=20，即00000101左移2位变为00010100，结果为20。 注意：右移运算符\u0026raquo;将操作数的二进制位向右移动指定的位数，高位补符号位（正数补0，负数补1），低位丢弃。例如：-5\u0026raquo;2=-2，即11111011右移2位变为11111110，结果为-2。 字符串比较注意：\n== 比较的是引用（内存地址），不是内容；equals()方法比较的是内容。使用compareTo()方法可以比较字符串的内容。字符串比较使用equals()方法，而不是==运算符。\n短路求值机制\n逻辑与（\u0026amp;\u0026amp;）：如果左操作数为false，右操作数不会被求值，直接返回false。 逻辑或（||）：如果左操作数为true，右操作数不会被求值，直接返回true。 可以提高程序性能，避免不必要的计算。\nJava 输入和输出 # Scanner方法详解\nScanner类是java.util包中的一个类，用于从输入流中读取数据。常用于从控制台读取用户输入的数据。\nScanner类的常用方法 next()：读取一个字符串，遇到空格、制表符或换行符结束。 nextInt()：读取一个整数，遇到空格、制表符或换行符结束。 nextDouble()：读取一个浮点数，遇到空格、制表符或换行符结束。 nextLine()：读取一行字符串，包括空格、制表符和换行符。 hasNext()：判断是否还有下一个输入项。 hasNextInt()：判断是否还有下一个整数输入项。 hasNextDouble()：判断是否还有下一个浮点数输入项。 使用nextInt()方法后，如果要使用nextLine()方法，需要在nextInt()方法后调用一次nextLine()方法，将换行符消耗掉。 Scanner使用完毕之后，应该调用close()方法关闭Scanner对象，释放资源。 使用try-catch语句来处理Scanner类可能抛出的异常，例如：InputMismatchException、NoSuchElementException等。\nJava 类型转换 # 类型转换分类：\n自动类型转换（隐式转换）：由编译器自动完成；（由小范围向大范围转换） 强制类型转换（显式转换）：需要程序员明确指定。（由大范围向小范围转换） 包装类转换：基本类型与包装类之间的转换（性能开销大） 字符串转换：字符串与其他类型之间的转换 由小到大： char-byte-short-int-long-float-double\n由小到大的转换：可以存在精度丢失，例如：将int类型转换为float类型时，可能会丢失小数部分。 由大到小的转换：可能会数据溢出，例如：将long类型转换为int类型时，可能会丢失高位数据。 ","date":"2021年1月8日","externalUrl":null,"permalink":"/posts/java-base02/","section":"全部文章","summary":"","title":"Java 基础语法","type":"posts"},{"content":"","date":"2021年1月8日","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","section":"Tags","summary":"","title":"基础语法","type":"tags"},{"content":"Java 入门基础：Java 简介，JDK、JRE、JVM、Hello World 程序。\n1. Java 简介 # 1.1 简述Java语言的主要特性 # Java 是一种面向对象的编程语言，具有封装、多态、继承的基础特性，同时也具有以下主要特性：\n平台独立性：Java 程序编译后生成字节码，在任何安装了 Java 运行环境（JRE）的平台上都可以运行。 自动内存管理：Java 虚拟机（JVM）负责管理内存，开发人员无需手动分配和释放内存。 异常处理：Java 提供了强大的异常处理机制，使程序能够处理运行时错误。 多线程支持：Java 支持多线程编程，允许程序并发执行多个任务。 丰富的类库：Java 提供了丰富的类库，开发人员可以利用这些类库快速开发应用程序。 1.2 解释Java程序的编译和运行过程 # Java 程序的编译和运行过程包括以下几个步骤：\n编写源代码：使用文本编辑器或集成开发环境（IDE）编写 Java 源代码文件（.java 文件）。 编译源代码：使用 Java 编译器（javac）将源代码编译为字节码文件（.class 文件）。 运行字节码：使用 Java 虚拟机（JVM）运行编译后的字节码文件。 加载类：JVM 加载字节码文件，并在内存中创建类的实例。 执行程序：JVM 执行字节码指令，完成程序的运行。 垃圾回收：JVM 自动管理内存，回收不再使用的对象占用的内存空间。 结束程序：程序执行完毕后，JVM 结束程序的运行。 输出结果：程序的输出结果显示在控制台或指定的输出设备上。 一张图先印在脑子里\n源码 Hello.java →【javac 编译】→ 字节码 Hello.class →【java 运行】→ 机器码（JIT 后） 三句话记住核心\njavac 只做一件事：把 .java 人类源码翻译成 .class 字节码（中立、跨平台）。 java 启动 JVM → 加载 .class → 字节码校验 → 解释执行 + 热点代码 JIT 成本地机器码。 不同操作系统装不同的 JVM，所以同一份 .class 文件能在 Windows/Mac/Linux 上跑，即“一次编译，到处运行”。 十行命令全程肉眼可见\n# 1. 写源码 cat \u0026gt; Hello.java \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; public class Hello { public static void main(String[] args) { System.out.println(\u0026#34;compile once, run anywhere\u0026#34;); } } EOF # 2. 编译：源码→字节码 javac Hello.java # 生成 Hello.class（二进制，可用 hexdump 看） # 3. 运行：JVM 装载并执行 java Hello # 注意后面不带 .class 输出：\ncompile once, run anywhere 细节放大镜（面试常问）\n阶段 关键文件/组件 做了什么 编译期 javac 词法分析 → 语法树 → 语义分析 → 生成字节码指令 类装载 ClassLoader 加载 .class → 创建 Class 对象 → 方法区/元空间存类型信息 字节码校验 Bytecode Verifier 检查跳转到非法地址、操作数栈溢出等，防止恶意代码 执行引擎 解释器 + JIT (HotSpot C1/C2) 先解释执行，热点代码（默认 1 万次调用）编译成本地机器码并缓存 垃圾回收 GC 线程 回收堆上不再可达的对象，让程序员不用手动 free 动手验证 JIT 的存在\njava -XX:+PrintCompilation Hello 能看到类似：\n87 1 3 java.lang.String::hashCode (56 bytes) 即热点方法被即时编译成高效机器码。\n常见误区提醒\n误区 1：Java 是“纯解释”执行。\n→ 错！热点代码会被 JIT 编译，速度与 C++ 接近。 误区 2：javac 把代码直接编译成机器码。\n→ 错！javac 只到字节码，机器码是 JVM 运行时按需生成的。 误区 3：运行时必须带着源码 .java。\n→ 错！只需要 .class 或打包后的 .jar。 一张命令速查表（保存备用）\n任务 命令 编译单个文件 javac Hello.java 编译并指定输出目录 javac -d out Hello.java 运行类 java -cp out Hello 打包 jar cf hello.jar -C out . 运行 jar java -jar hello.jar （需 jar 内指定 Main-Class） 查看字节码 javap -c Hello 查看 JIT 编译 java -XX:+PrintCompilation Hello 1.3 比较 Java 与 C++ 的主要区别 # 特性 Java C++ 内存管理 自动垃圾回收（JVM 管理内存） 手动内存管理（需 malloc/free） 平台依赖性 跨平台（一次编译，到处运行） 平台相关（需针对不同平台编译） 编译方式 编译成字节码，由 JVM 解释执行或 JIT 编译成本地机器码 编译成本地机器码 指针支持 不支持指针，使用引用 支持指针操作 多继承 不支持类的多继承，支持接口多继承 支持类的多继承 运行时性能 较高（JIT 优化） 通常较高（直接机器码执行） 标准库 丰富的标准类库 丰富的标准模板库（STL） 异常处理 强制异常处理机制 可选异常处理机制 多线程支持 内置多线程支持 通过库支持多线程 编译器 javac g++, clang++ 内存管理：有没有“垃圾回收”\n维度 Java C++ 谁来回收 自动 GC（Garbage Collector） 程序员自己 new/delete 或智能指针 写代码感觉 只管 new，不管 free 必须配对，否则内存泄漏/悬空指针 运行代价 停顿式 GC 带来微小延迟 无 GC 停顿，但可能野指针崩溃 一句话总结：\nJava 像“保洁阿姨每天帮你倒垃圾”；C++ 像“自己做饭自己洗碗，洗不干净就招蟑螂”。\n面向对象模型：有没有“真正的类”\n维度 Java C++ 基本类型 int/boolean/char 不是对象 int/bool/char 就是普通内存值 多态机制 默认虚方法（virtual） 需手动加 virtual，否则静态绑定 多重继承 类只能单继承，接口可多继承 类可多继承，带来菱形问题（需 virtual 基类） 运行时类型 反射随时拿到 Class\u0026lt;?\u0026gt; 只有虚表，RTTI 有限且需开启编译器选项 一句话总结：\nJava 把“面向对象”写进 DNA，连数组都是对象；C++ 既能面向对象也能面向过程，还能面向汇编。\n跨平台方式：编译一次 vs 每个平台编一次\n维度 Java C++ 产出文件 .class 字节码 机器码可执行文件/动态库 运行依赖 目标机器装对应 JVM 目标机器无需额外运行时，但可能要装 VC++ redist 性能 先解释后 JIT，峰值≈C++ 90% 编译期极致优化，可内联汇编 移植成本 最低，同一份 jar 到处跑 需重新编译，宏/条件编译处理平台差异 一句话总结：\nJava 带着“翻译机（JVM）”出差；C++ 提前把当地话说好，换城市就重学方言。\n2 个常考差异（面试加料）\n指针 vs 引用\nC++ 有指针运算、int* p++ 可以直接窜内存；Java 只有“安全引用”，不能做任何地址运算，杜绝野指针。\n异常机制\nJava 必检异常（checked exception）强迫方法签名声明；C++ 异常任意抛，不声明也能编译通过。\n2. Java 开发环境 # JDK（Java Development Kit） 是 Java 开发的基础工具包，包含了编译、调试、运行等必要的工具。(包含javac、java、javadoc、jar、jdb、javap-反编译器显示class文件) JRE（Java Runtime Environment） 是 Java 运行时环境，包含了 JVM 和 Java 标准类库。 JVM（Java Virtual Machine） 是 Java 虚拟机，负责执行 Java 字节码，实现跨平台运行。（字节码执行、内存管理、垃圾回收、安全管理、异常处理） IDEA（IntelliJ IDEA） 是 Java 开发的集成开发环境（IDE），提供了代码编辑、调试、构建等功能。 3. JVM内存结构 # JVM 内存结构主要包括以下几个部分：\n方法区（Method Area）：存储类信息、静态变量、常量池等。 堆内存（Heap）：存储对象实例和数组，是垃圾回收的主要区域。 栈内存（Stack）：存储方法调用、局部变量等。 本地方法栈（Native Method Stack）：存储本地方法调用。 程序计数器（Program Counter Register）：记录当前线程执行的字节码指令地址。 为什么需要jvm：实现跨平台运行、自动内存管理、提供安全沙箱、优化程序执行、统一的异常处理机制。\n","date":"2021年1月8日","externalUrl":null,"permalink":"/posts/java-base01/","section":"全部文章","summary":"","title":"Java 入门基础","type":"posts"},{"content":"","date":"2021年1月8日","externalUrl":null,"permalink":"/tags/%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/","section":"Tags","summary":"","title":"基础环境","type":"tags"},{"content":"学习Java之前，先要学习基础环境搭建，包括安装JDK、配置环境变量、安装IDE等；还要掌握Maven的使用，包括安装Maven、配置环境变量、创建Maven项目等;最后要掌握Java的专业开发工具IntelliJ IDEA等。\n1. 一键安装 JDK 17（LTS） # # 0. 先装 Homebrew（若已装可跳过） /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; # 1. 用 brew 装 JDK 17（自动配好环境变量） brew install openjdk@17 # 2. 让系统认出 java（一次性） echo \u0026#39;export PATH=\u0026#34;/opt/homebrew/opt/openjdk@17/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc # 3. 验证 java -version # 应显示 openjdk 17.0.x javac -version # 同上 若出现版本号即成功；未出现请重启终端再试 。\n2. 一键安装 Maven（Java 依赖管理神器） # brew install maven # 验证 mvn -v # 能看到 Apache Maven 3.9.x 与 JDK 17 路径 Maven 默认仓库在国外，第一次下载依赖较慢，可换阿里云镜像（可选）：\nmkdir -p ~/.m2 cat \u0026gt; ~/.m2/settings.xml \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39; \u0026lt;settings\u0026gt; \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;aliyunmaven\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Aliyun Maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;/settings\u0026gt; EOF 3. 一键安装 IntelliJ IDEA # 社区版免费，最好不要用社区版，后续上SpringBoot等框架时会遇到问题\nbrew install --cask intellij-idea-ce 装完在“启动台”里会出现 IntelliJ IDEA CE，首次打开按提示：\n主题/插件页一路 Skip All and Set Defaults 新建项目 → 左侧选 Maven → 右侧 SDK 选 openjdk-17 → Finish 在 src/main/java 右键 → New Java Class → 输入 Hello → 写 main 方法： public class Hello { public static void main(String[] args) { System.out.println(\u0026#34;Hello, Java on Mac!\u0026#34;); } } 点击绿色 ▶️ 运行，控制台打印即环境 100 % OK 。\n常用快捷键（先记 3 个） # 功能 快捷键 运行 Control + R 格式化代码 Command + Option + L 全局搜索类 双击 Shift 4. 一键安装 MySQL 8.0 # brew install mysql@8.0 安装完会提示它不在默认 PATH，我们顺手配好：\necho \u0026#39;export PATH=\u0026#34;/opt/homebrew/opt/mysql@8.0/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc # 第一次启动 brew services start mysql@8.0 # 按提示设 root 密码、删除匿名用户、禁止远程 root 登录等 mysql_secure_installation 全部选 y 即可，密码记好 。\n验证 MySQL 是否安装成功：\nmysql -uroot -p 输入刚才的密码，看到 mysql\u0026gt; 提示符后执行：\nCREATE DATABASE demo CHARACTER SET utf8mb4; exit 能正常进入即安装成功 。\n让 MySQL 开机自启（可选）\nbrew services start mysql@8.0 # 已经自带开机自启 以后想停/重启：\nbrew services stop mysql@8.0 brew services restart mysql@8.0 5. 目录速查（记不住就回来翻） # 工具 安装路径 配置文件 JDK /opt/homebrew/opt/openjdk@17 ~/.zshrc Maven /opt/homebrew/opt/maven ~/.m2/settings.xml IDEA /Applications/IntelliJ IDEA CE.app ~/Library/Preferences/IdeaIC2025.x ","date":"2021年1月8日","externalUrl":null,"permalink":"/posts/java-env-base/","section":"全部文章","summary":"","title":"基础环境搭建","type":"posts"},{"content":"","date":"2021年1月8日","externalUrl":null,"permalink":"/tags/%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/","section":"Tags","summary":"","title":"入门基础","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"欢迎你来到我的个人博客！\n我是 Holly，一个还在起步路上的技术小白。\n现在的我，正埋头啃着 Java 和 MySQL 的基础语法，一遍遍调试代码，一次次理解数据表之间的关系。我知道自己还很“菜”，但我不怕承认——因为每个大神都曾是从第一行 “Hello, World!” 开始的。\n我选择用这个博客记录下学习中的每一个脚印：可能是某个让我卡住三天的 Bug，也可能是一段终于跑通的脚本；是读书笔记，也是实战心得。我不追求高深，只想真实地留下自己成长的痕迹。\n我希望自己能一步步走向更广阔的领域：分布式系统、中间件、云计算、大模型……这些领域我都想探索，我愿意用时间和努力去靠近它们，也愿意和其他的人分享我的经验和发现。\n我相信：保持天真，才能对未知保持好奇；保持烂漫，才能在枯燥的代码中找到乐趣；保持纯粹，才能在复杂的系统中找到简单的解决方案。\n这里也会分享我放在 GitHub 和 Gitee 上的项目——也许它们现在还很稚嫩，但每一个都是我思考与尝试的结晶。\n如果你也正在学习路上，欢迎你常来看看。我们可以一起交流，彼此鼓励。\n永远天真，永远烂漫，永远纯粹，永远在路上。\n联系方式 # GitHub: github.com/hollyblog/ Gitee: gitee.com/hollyblog/ Email: 2285549633@qq.com ","externalUrl":null,"permalink":"/about/","section":"关于我","summary":"","title":"关于我","type":"about"}]