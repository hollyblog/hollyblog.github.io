---
title: "Java 面向对象进阶"
date: 2021-01-09T22:18:05+08:00
draft: false
description: "Java 面向对象进阶：继承、方法重写、super关键字、final关键字、抽象类和抽象方法、接口（interface）、多态、封装、instanceof关键字。"
tags: ["Java", "面向对象进阶"]
categories: ["Java"]
---
Java 面向对象进阶：继承、方法重写、super关键字、final关键字、抽象类和抽象方法、接口（interface）、多态、封装、instanceof关键字。
## Java 继承
继承是面向对象编程的一个重要特性，它允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的重用和扩展。
- extends关键字：建立继承关系的关键字；子类获得父类的属性和方法；java只支持单继承；所有类都隐式继承object类
- 方法重写（override）：子类重新定义父类的方法；使用@override注解标记；方法签名必须完全相同；实现多态的基础
- super关键字：访问父类的成员；调用父类的构造方法；调用父类被重写的方法；解决命名冲突
> protected修饰符是专门为继承设计的，它允许子类访问父类的成员，但是不允许其他包中的非子类访问。
>
> 子类重写父类方法时，访问修饰符的限制是：子类方法的访问权限不能低于父类方法的访问权限。可以更宽松，但不能更严格。
>
> 子类重写父类方法时，返回值类型需要兼容：可以为父类返回值类型的子类。
>
> 异常声明限制：不能抛出比父类方法更宽泛的异常。


## Java 方法重写
方法重写（override）：子类重新定义父类方法；使用@override注解标记；方法签名必须完全相同；实现多态的基础。

方法重写必须遵循一系列严格的规则，以确保代码的正确性和一致性：
1. 方法签名必须完全相同：包括方法名称、参数类型和参数顺序。
2. 访问修饰符不能更严格：子类方法的访问权限不能比父类更严格。
3. 返回类型必须相同或者是子类类型：子类方法的返回类型必须与父类方法相同，或者是其子类类型。
4. 异常声明不能更宽泛：子类方法不能抛出比父类更宽泛的检查异常；
5. final方法、static方法和private方法不能被重写。
6. 构造方法不能被重写。

## Java super关键字
super关键字：访问父类的成员；调用父类的构造方法；调用父类被重写方法；解决命名冲突。
> ❗️super关键字的主要用途
> - 调用父类构造方法：使用super(...)调用父类的构造方法，必须是子类构造方法的第一行代码。
> - 访问父类成员变量（属性）：使用super.成员变量名访问父类的成员变量。
> - 调用父类方法：使用super.方法名(...)调用父类 

> ⚠️重要规则
> super关键字只能在子类中使用，不能在静态方法中使用，因为静态方法不属于任何实例。
> 如果没有显式调用super(),编译器会自动插入super()调用父类的无参构造方法。
> 如果父类没有无参构造方法，子类必须显式调用父类的其他构造方法，否则编译错误。

super 和 this 的区别

关键字 | 作用 | 示例 | 使用场景 | 
|-----|------|------|--------|
super | 访问父类的成员变量和方法，调用父类的构造方法 | super.variable, super.method(), super() | 在子类中访问或调用父类的成员或构造方法 |
this | 访问当前实例的成员变量和方法 | this.variable, this.method() | 在子类中访问当前实例的成员变量和方法 |
super() | 调用父类的构造方法 | super() | 在子类的构造方法中调用父类的构造方法 |
this()  | 调用当前类的另一个构造方法 | this() | 在当前类的构造方法中调用另一个构造方法 |

## Java final 关键字
> final关键字用于声明常量、方法和类，表示不可更改的含义。用于限制继承、重写和重新赋值。它可以修饰类、方法和变量，确保被修饰的元素具有“最终”的特性，不能被改变。

- final类：final类不能被继承，不能有子类。（如String类，Integer、Double等包装类）
- final方法：final方法不能被子类重写，但可以被子类继承和调用。（保证核心重要逻辑不被修改，在模板方法模式中保护关键步骤，编译器可以对final方法进行内联优化）
- final变量：final变量不能被重新赋值。

| final变量类型 | 初始化时机 | 特点 | 应用场景 |
|--------------|------------|------|----------|
|final静态变量 |  类加载时(声明时或者静态代码块) | 只能赋值一次，通常用大写字母命名（类级别常量，所有实例共享） | 定义常量，如数学常量、配置参数等 |
|final实例变量 | 声明时或者构造函数（对象创建时） | 每个对象可以有不同的值（实例级别的常量，每个对象独有）| 不可变对象的字段 |
|fina局部常量 | 使用前任意时机 | 方法内部常量 | 临时常量、lambda表达式 |
|final方法参数 | 方法调用时 | 方法内部不可修改参数值 | 保护方法参数不被修改 |
|final修饰引用变量 | 赋值时 | 引用地址不可变，但对象内容可变 | 不可变引用 |

### final常量和变量有什么区别？
final变量是语法概念，常量是语义概念。final变量一旦赋值就不能更改，而常量是指在程序运行过程中其值不会改变的量。通常使用static final关键字组合来定义常量。
### final方法可以被重载吗？
可以。final只是防止重写（override），不影响重载。
### 为什么String类是final的？
为了安全性、性能优化和字符串池的实现。
### final变量一定要在声明时初始化吗？
不一定。实例final变量可以在构造函数中初始化，静态final变量可以在静态代码块中初始化，局部final变量可以延迟初始化。

## Java 抽象类和抽象方法abstract
抽象类是不能实例化的类，用于定义子类的通用属性和行为。抽象方法是只有声明没有实现的方法，抽象方法只能存在于抽象类中，必须在子类中重写。
- 不能实例化：不能使用new关键字创建抽象类的对象。
- 可以有构造方法：用于初始化抽象类中的成员变量。
- 可以包含具体方法：提供通用的实现逻辑。
- 可以包含抽象方法：强制子类必须提供具体的实现。
- 可以有成员变量：存储对象的状态信息。
  
> ✅ 什么时候使用抽象类
> - 多个相关类需要共享代码时
> - 需要提供部分实现，部分留给子类时
> - 需要强制子类实现某些方法时
> - 定义算法骨架，具体步骤由子类实现时
> - 需要在类中定义实例变量时

> ❗️常用场景
> - 框架设计：定义框架的骨架结构，如spring框架中的抽象类；
> - 模板方法模式：定义算法模板，具体步骤由子类实现；
> - 工厂模式：抽象工厂类定义创建对象的接口
> - 数据访问层： 抽象dao类提供通用的数据库操作方法；
> - 业务逻辑层：抽象service类提供业务逻辑方法。

> ⚠️重要规则
> - 合理命名：使用清晰的类名表达抽象概念；
> - 文档注释：为抽象方法提供详细的文档说明
> - 构造方法：提供合适的构造方法初始化通用属性
> - 访问修饰符：合理使用protected让子类访问；
> - 方法设计：抽象方法应该有明确的职责和契约；
> - 单一职责： 每个抽象类应该有明确单一的职责。

### 抽象类和接口的区别
特性 | 抽象类 | 接口 |
----|--------|------
关键字 | abstract class | interface |
继承方式 | 使用extends关键字（单继承） | 使用implements关键字（多实现） |
方法 | 可以包含抽象方法和具体方法 | 只能包含抽象方法（Java 8及以上版本支持默认方法和静态方法） |
成员变量 | 可以有实例变量和静态变量 | 只能有静态常量
构造方法 | 可以有构造方法 | 不能有构造方法 |
访问修饰符 | 可以有各种访问修饰符 | 默认是public，不能有访问修饰符 |

## Java 接口（interface）
接口是定义类之间契约的工具，规定了类必须实现的方法和行为。接口支持多重继承，允许类实现多个接口。接口是一个完全抽象的类，它只包含常量（public static final）和抽象方法的声明（默认public abstract）。从java8开始，接口可以包含默认（deafult）方法和静态（static）方法。接口定义了类应该做什么，但不规定如何做。
> ⚠️ 接口成员的默认修饰符
> - 所有变量都是public static final（常量）；
> - 所有方法都是public abstract（抽象方法）；
> - 默认方法使用default关键字定义，可以有具体实现；
> - 静态方法使用static关键字定义，可以有具体实现；（属于接口本身，可以通过接口名调用，不能被实现类重写，静态方法必须有方法体，不需要在实现类中实现）
## Java 多态
多态是面向对象编程的三大特性之一，它允许不同类的对象对同一消息作出不同的响应。多态主要通过方法重写和动态绑定来实现的。
> 核心思想：“同一个接口，不同实现”，通过父类引用指向子类对象，在运行时根据对象的实际类型来决定调用哪个方法。

多态实现的条件：
- 继承关系：子类继承父类
- 方法重写：子类重写父类的方法
- 向上转型：父类引用指向子类对象
```java
//多态的基本示例
Animal animal1 = new Dog(); //向上转型
Animal animal2 = new Cat();
//动态绑定
animal1.makeSound(); //调用Dog类的makeSound方法
animal2.makeSound(); //调用Cat类的makeSound方法
``` 
> - 编译时多态（静态绑定）：方法重载（overload），在编译时根据参数类型和数量决定调用哪个方法。
> - 运行时多态（动态绑定）：方法重写（override），在运行时根据对象确定调用哪个方法。

> - 向上转型：将子类对象赋值给父类引用，自动进行的，无需强制转换；（只能访问父类中定义的方法，实际调用的是子类重写的方法（动态绑定））
> - 向下转型：将父类引用转换为子类对象，需要强制转换，可能会抛出ClassCastException异常。
> ```java 
>//向上转型
> Animal animal = new Dog();
> animal.makeSound();
> animal.move();
> animal.fetch(); //编译错误，Animal类没有fetch方法
>//向下转型
> if (animal instanceof Dog) {
>   Dog dog = (Dog) animal; //强制转换
>   dog.fetch(); //可以调用fetch方法
>}
> Cat cat = (Cat) animal; //可能抛出ClassCastException异常
> ```
> - instanceof运算符：判断对象是否是某个类的实例。（根据对象类型执行不同的逻辑，在处理混合类型集合时进行类型判断，实现类型安全的操作）
> - 运行时类型信息：Java中的对象可以存储任意类型的数据，但是对象本身只知道它存储了什么类型的数据，不能知道它存储的具体对象是什么类型。运行时类型信息（Runtime Type Information）就是指对象在运行时它的类型信息。
> - 动态方法分派：Java在运行时根据对象的实际类型来决定调用哪个方法，这个过程称为动态方法分派（Dynamic Method Dispatch）。
> - 向下转型必须使用instanceof关键字检查类型；如果类型不匹配会抛出ClassCastException;只有在确实需要访问子类特有方法时才使用。

> ❗️动态绑定的工作原理
> 1. 编译时：检查父类中是否有该方法
> 2. 运行时：根据对象的实际类型查找方法
> 3. 如果子类重写了该方法，调用子类的版本
> 4. 如果没有重写，调用父类的版本

> ✅实际应用场景
> - 图形界面编程
> - 数据库操作
> - 游戏开发

> ⚠️注意
> - 静态方法不支持多态：静态方法在编译时绑定
> - 静态方法不能被继承：静态方法在编译时绑定
> - 私有方法不支持多态：私有方法不能被重写
> - 构造方法不支持多态：构造方法不能被重写
> - 向下转型需谨慎：必须使用instanceof检查类型
> - 方法重写规则：访问修饰符不能更严格
> - **在多态中，父类引用只能访问父类中定义的方法，不能直接访问子类特有的方法，要访问子类特有的方法需要向下转型。**
> ```java 
>  //多态示例
> Animal animal = new Dog(); //向上转型
> ```
> - animal引用（Dog对象）既是Dog类型的实例，也是Animal类型的实例（因为继承关系）。
## Java 封装
封装是面向对象编程的基本特性之一，它将数据（属性）和行为（方法）绑定在一起，并隐藏对象的内部实现细节，只暴露必要的接口给外部使用。封装提高了代码的安全性、可维护性和可扩展性。
> 封装的核心思想是“隐藏实现细节，只暴露必要的接口“。这样可以保护对象的内部状态，防止外部代码的不当访问和修改，同时提高代码的安全性和可维护性。
- 访问修饰符：使用private、protected、public等修饰符来控制属性和方法的访问权限。
- 属性：封装的属性，通常使用private修饰符来隐藏属性的实现细节。
- 方法：封装的方法，通常使用private修饰符来隐藏方法的实现细节。
- 提供必要的getter和setter方法：通过公共的getter和setter方法来访问和修改私有属性，实现对属性的控制和保护。
- 在setter方法中进行数据验证。
- 不变形：对于不应该改变的字段，只提供getter方法，不提供setter方法。
- 防御性复制：对于可变对象类型的属性，在getter方法中返回属性的副本，而不是直接返回属性本身，防止外部代码修改对象的内部状态。
## Java instanceof关键字
instanceof关键字用于判断一个对象是否是某个类的实例，或者是否实现了某个接口。它返回一个布尔值，表示对象是否属于指定的类型。
```java
if (object instanceof ClassName) {
    // object是ClassName类的实例
    //object要检查的对象引用
    //ClassName要检查的类或接口或数组类型
    //返回值：boolean类型，true或false
}
```
基本类型检查
```java
//创建不同类型的对象
Object obj1 = new String("Hello");
Object obj2 = new Integer(10);
//使用instanceof关键字进行类型检查
System.out.println(obj1 instanceof String); //true
System.out.println(obj1 instanceof Object); //true
System.out.println(obj2 instanceof Integer); //true
System.out.println(obj2 instanceof Number); //true
System.out.println(obj2 instanceof String); //false
Object obj4 = null;
System.out.println(obj4 instanceof Object); //false
System.out.println(null instanceof String); //false
```
> ⚠️注意
> - null引用：使用instanceof检查null引用时，结果总是false。
> - 继承关系：如果对象是子类的实例，instanceof检查父类时返回true。
> - 接口实现：如果对象实现了某个接口，instanceof检查该接口时返回true。
> - 数组支持：支持对数据类型的检查。
> - 编译时检查：instanceof在编译时进行类型检查，确保类型兼容性。
> - 向下转型：在进行向下转型之前，使用instanceof进行类型检查，防止ClassCastException异常。
> - **优先使用多态，而不是instanceof**：过度使用instanceof可能导致代码复杂且难以维护，优先考虑使用多态来实现不同类型对象的行为。
> - 基本数据类型：instanceof不能用于基本数据类型，只能用于引用类型。

可以使用其他方式或者设计模型替代instanceof的使用，例如：
- 多态设计：通过方法重写实现不同类型对象的行为，而不是使用instanceof进行类型检查。
- 设计模式：使用设计模式（如访问者模式）来处理不同类型对象的操作，而不是使用instanceof进行类型检查。
```java
//访问者模式替代instanceof
interface ShapeVisitor {
    void visit(Circle circle);
    void visit(Rectangle rectangle);
}
abstract class Shape {
    abstract void accept(ShapeVisitor visitor);
}
class Circle extends Shape {
    @Override
    void accept(ShapeVisitor visitor) {
        visitor.visit(this);    
    }
}
class Rectangle extends Shape {
    @Override
    void accept(ShapeVisitor visitor) {
        visitor.visit(this);    
    }
}
```
